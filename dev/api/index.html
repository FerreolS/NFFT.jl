<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · NFFT</title><link rel="canonical" href="https://tknopp.github.io/NFFT.jl/api/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NFFT logo"/></a><div class="docs-package-name"><span class="docs-autofit">NFFT</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../directional/">Directional</a></li><li><a class="tocitem" href="../density/">Density</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tknopp/NFFT.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>In the following, you find the documentation of some, and hopefully soon all, exported functions of the <a href="https://github.com/tknopp/NFFT.jl">NFFT.jl</a> package:</p><ul><li><a href="#NFFT.NFFTPlan-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any, Any, Any}} where {D, T}"><code>NFFT.NFFTPlan</code></a></li><li><a href="#NFFT.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, Matrix{T}}, Tuple{Any, Matrix{T}, Any}, Tuple{Any, Matrix{T}, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any, Any}} where T"><code>NFFT.calculateToeplitzKernel</code></a></li><li><a href="#NFFT.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan, Matrix{T}, Any}} where T"><code>NFFT.calculateToeplitzKernel!</code></a></li><li><a href="#NFFT.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}"><code>NFFT.convolveToeplitzKernel!</code></a></li><li><a href="#NFFT.ndft-Union{Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{T, D}}} where {D, T}"><code>NFFT.ndft</code></a></li><li><a href="#NFFT.ndft!-Union{Tuple{Tg}, Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{Tg}, AbstractArray{T, D}}} where {D, T, Tg}"><code>NFFT.ndft!</code></a></li><li><a href="#NFFT.ndft_adjoint-Tuple{NFFT.NFFTPlan, AbstractVector}"><code>NFFT.ndft_adjoint</code></a></li><li><a href="#NFFT.ndft_adjoint!-Union{Tuple{Tg}, Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{Tg, D}, AbstractVector{T}}} where {D, T, Tg}"><code>NFFT.ndft_adjoint!</code></a></li><li><a href="#NFFT.nfft-Union{Tuple{D}, Tuple{T}, Tuple{Any, AbstractArray{T, D}, Vararg{Any}}} where {T, D}"><code>NFFT.nfft</code></a></li><li><a href="#NFFT.nfft-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{AbstractNFFTPlan{D, 0, T}, AbstractArray{U, D}, Vararg{Any}}} where {D, T, U}"><code>NFFT.nfft</code></a></li><li><a href="#NFFT.nfft!-Union{Tuple{T}, Tuple{DIM}, Tuple{D}, Tuple{NFFT.NFFTPlan{D, DIM, T}, AbstractArray, StridedArray}} where {D, DIM, T}"><code>NFFT.nfft!</code></a></li><li><a href="#NFFT.nfft_adjoint-Union{Tuple{U}, Tuple{T}, Tuple{DIM}, Tuple{D}, Tuple{AbstractNFFTPlan{D, DIM, T}, AbstractArray{U}, Vararg{Any}}} where {D, DIM, T, U}"><code>NFFT.nfft_adjoint</code></a></li><li><a href="#NFFT.nfft_adjoint-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}, Vararg{Any}}} where T"><code>NFFT.nfft_adjoint</code></a></li><li><a href="#NFFT.nfft_adjoint!-Tuple{NFFT.NFFTPlan, AbstractArray, StridedArray}"><code>NFFT.nfft_adjoint!</code></a></li><li><a href="#NFFT.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}"><code>NFFT.plan_nfft</code></a></li><li><a href="#NFFT.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Vector{T}, Integer, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}"><code>NFFT.plan_nfft</code></a></li><li><a href="#NFFT.precomp_apodIdx-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Tuple{Vararg{Int64, D}}}} where D"><code>NFFT.precomp_apodIdx</code></a></li><li><a href="#NFFT.precomp_windowHatInvLUT-Union{Tuple{D}, Tuple{Type, Function, Tuple{Vararg{Int64, D}}, Real, Int64}} where D"><code>NFFT.precomp_windowHatInvLUT</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="NFFT.NFFTPlan-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any, Any, Any}} where {D, T}" href="#NFFT.NFFTPlan-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any, Any}, Tuple{AbstractVector{T}, Integer, Tuple{Vararg{Int64, D}}, Any, Any, Any, Any}} where {D, T}"><code>NFFT.NFFTPlan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    NFFTPlan(x, d, N, ...) -&gt; plan</code></pre><p>Compute <em>directional</em> NFFT plan: A 1D plan that is applied along dimension <code>d</code> of a <code>D</code> dimensional array of size <code>N</code> with sampling locations <code>x</code> (a vector).</p><p>It takes as optional keywords all the keywords supported by <code>plan_fft</code> function (like <code>flags</code> and <code>timelimit</code>).  See documentation of <code>plan_fft</code> for reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/CpuNFFT.jl#L134-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan, Matrix{T}, Any}} where T" href="#NFFT.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan, Matrix{T}, Any}} where T"><code>NFFT.calculateToeplitzKernel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculateToeplitzKernel!(f::Array{Complex{T}}, p::AbstractNFFTPlan, tr::Matrix{T}, fftplan)</code></pre><p>Calculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure and writes it in-place in <code>f</code>, which has to be twice the size of the desired image matrix, as the Toeplitz trick requires an oversampling factor of 2 (cf. <a href="https://cds.ismrm.org/ismrm-2001/PDF3/0767.pdf">Wajer, F. T. A. W., and K. P. Pruessmann. &quot;Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.&quot; Proc. Intl. Soc. Mag. Res. Med. 2001.</a>). The type of the kernel <code>f</code> has to be <code>Complex{T}</code>, i.e. the complex of the k-space trajectory&#39;s type; for speed and memory efficiecy, call this function with <code>Float32.(tr)</code>, and set the type of <code>f</code> accordingly.</p><p><strong>Required Arguments</strong></p><ul><li><code>f::Array{T}</code>: Array in which the kernel will be written.</li><li><code>p::AbstractNFFTPlan</code>: NFFTPlan with the same dimentions as <code>tr</code>, which will be overwritten in place.</li><li><code>tr::Matrix{T}</code>: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. <code>tr[i] ∈ [-0.5, 0.5] ∀ i</code>. The matrix has the size <code>2 x Nsamples</code> for 2D imaging with a trajectory length <code>Nsamples</code>, and <code>3 x Nsamples</code> for 3D imaging.</li><li><code>fftplan</code>: plan for the final FFT of the Kernal from image to k-space. Therefore, it has to have twice the size of the original image. Calculate, e.g., with <code>fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using FFTW

julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(2, 1000) .- 0.5);

julia&gt; p = plan_nfft(trj, (2Nx,2Nx))
NFFTPlan with 1000 sampling points for (64, 64) array

julia&gt; fftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=FFTW.MEASURE);

julia&gt; λ = Array{ComplexF32}(undef, 2Nx, 2Nx);

julia&gt; calculateToeplitzKernel!(λ, p, trj, fftplan);

julia&gt; x = randn(ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(x, λ);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/Toeplitz.jl#L89-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, Matrix{T}}, Tuple{Any, Matrix{T}, Any}, Tuple{Any, Matrix{T}, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any, Any}} where T" href="#NFFT.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, Matrix{T}}, Tuple{Any, Matrix{T}, Any}, Tuple{Any, Matrix{T}, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any, Any}} where T"><code>NFFT.calculateToeplitzKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculateToeplitzKernel(shape, tr::Matrix{T}[, m = 4, sigma = 2.0, window = :kaiser_bessel, K = 2000; fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE), kwargs...])</code></pre><p>Calculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure. The output is an array of twice the size of <code>shape</code>, as the Toeplitz trick requires an oversampling factor of 2 (cf. <a href="https://cds.ismrm.org/ismrm-2001/PDF3/0767.pdf">Wajer, F. T. A. W., and K. P. Pruessmann. &quot;Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.&quot; Proc. Intl. Soc. Mag. Res. Med. 2001.</a>). The type of the kernel is <code>Complex{T}</code>, i.e. the complex of the k-space trajectory&#39;s type; for speed and memory efficiecy, call this function with <code>Float32.(tr)</code>, and the kernel will also be <code>Float32</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>shape::NTuple(Int)</code>: size of the image; e.g. <code>(256, 256)</code> for 2D imaging, or <code>(256,256,128)</code> for 3D imaging</li><li><code>tr::Matrix{T}</code>: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. <code>tr[i] ∈ [-0.5, 0.5] ∀ i</code>. The matrix has the size <code>2 x Nsamples</code> for 2D imaging with a trajectory length <code>Nsamples</code>, and <code>3 x Nsamples</code> for 3D imaging.</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>m::Int</code>: nfft kernel size (used to calculate the Toeplitz kernel); <code>default = 4</code></li><li><code>sigma::Number</code>: nfft oversampling factor during the calculation of the Toeplitz kernel; <code>default = 2</code></li><li><code>window::Symbol</code>: Window function of the nfft (c.f. <a href="@ref"><code>getWindow</code></a>); <code>default = :kaiser_bessel</code></li><li><code>K::Int</code>: <code>default= 2000</code> # TODO: describe meaning of k</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>fftplan</code>: plan for the final FFT of the Kernal from image to k-space. Therefore, it has to have twice the size of the original image. <code>default = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE)</code>. If this constructor is used many times, it is worth to precompute the plan with <code>plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE)</code> and reuse it.</li><li><code>kwargs</code>: Passed on to <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.plan_fft!"><code>plan_fft!</code></a> via <code>NFFTPlan</code>; can be used to modify the flags <code>flags=FFTW.ESTIMATE, timelimit=Inf</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(2, 1000) .- 0.5);

julia&gt; λ = calculateToeplitzKernel((Nx, Nx), trj)
64×64 Matrix{ComplexF32}:
  1697.69+483.218im   -147.57-257.719im  …   604.041-479.841im
  1858.23-220.871im   3723.91-4.62838im      3917.46+217.494im
  3260.49+249.208im   1719.05-23.7088im      1935.48-245.831im
  1115.56-210.368im  -85.7251-15.1312im      499.092+206.991im
  3232.19+666.149im  -927.182-440.649im      1048.98-662.772im
 -2818.12-640.593im   2892.04+415.094im  …   -435.71+637.216im
  3019.67+377.944im   1978.27-152.445im      4267.19-374.567im
  711.755-499.0im     11091.8+273.5im        822.519+495.623im
 -436.376+576.158im   2085.76-350.659im      280.188-572.781im
 -460.382-658.799im  -402.648+433.299im      1579.94+655.422im
         ⋮                               ⋱
  863.552-940.384im  -571.564+714.885im  …   325.992+937.007im
  -554.64+283.37im   -416.581-57.8705im     -295.217-279.993im
  680.462-381.469im   437.636+155.97im       381.239+378.092im
 -1769.07+404.678im   291.916-179.179im      192.257-401.301im
  1502.99-212.153im   3114.76-13.346im       3939.76+208.776im
  1192.88+274.105im   728.321-48.6058im  …   593.152-270.728im
  318.763-370.158im  -273.715+144.659im     -323.591+366.781im
 -810.074+257.924im  -144.068-32.4241im      -44.218-254.546im
  6650.49-187.076im  -1154.77-38.4236im      1493.98+183.699im

julia&gt; x = randn(ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(x, λ)
32×32 Matrix{ComplexF32}:
 -2548.17+350.061im  -83.5555-1118.35im  …  -369.412+1283.74im
 -232.842+353.766im   950.106+2080.18im     -598.713-944.801im
 -1009.52-1121.52im    93.405+693.621im      1390.72+197.977im
  1812.78-9.56223im   275.549+599.843im      458.824-1033.59im
 -1213.11-163.169im  -329.302-1185.4im       356.961-1026.23im
  1479.05-1515.57im   1149.94-1208.13im  …   410.585+209.635im
  1021.91+1114.42im   571.518+509.203im     -1047.46+647.597im
 -12.9759+900.257im   880.053+758.609im     -1017.49-1609.38im
  398.851+171.48im     830.65+1170.5im       1277.94-2639.44im
  188.979+789.158im   415.594+370.381im       101.68-1864.72im
         ⋮                               ⋱
  -1458.0-1250.08im   2466.35+374.447im     -352.156+306.172im
  828.511-333.487im   2105.72+344.53im      -401.738-782.178im
 -602.072-108.482im  -1368.96+1090.78im  …  -129.634-1951.61im
  169.226-1887.22im   1637.13-460.677im      1077.74+775.838im
  593.828+1301.49im  -1322.09+194.759im     -1700.84+531.625im
  775.017-208.648im    1361.0-528.349im     -434.659+206.32im
  1044.89-874.581im  -286.478+795.039im     -1186.11+879.18im
 -665.938+1052.24im   -34.669-1059.52im  …   -1700.0-1452.94im
 -303.172-1110.12im   2510.89+163.711im     -500.883-1606.86im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/Toeplitz.jl#L5-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}" href="#NFFT.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}"><code>NFFT.convolveToeplitzKernel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convolveToeplitzKernel!(x::Array{T,N}, λ::Array{T,N}[, fftplan = plan_fft(λ; flags=FFTW.ESTIMATE), ifftplan = plan_ifft(λ; flags=FFTW.ESTIMATE), xOS1 = similar(λ), xOS2 = similar(λ)])</code></pre><p>Convolves the image <code>x</code> with the Toeplitz kernel <code>λ</code> and overwrites <code>x</code> with the result. <code>x</code> is also returned for convenience. As this function is commonly applied many times, it is highly recommened to pre-allocate / pre-compute all optional arguments. By doing so, this entire function is non-allocating.</p><p><strong>Required Arguments</strong></p><ul><li><code>x::Array{T,N}</code>: Input image that will be overwritten with the result. <code>x</code> is a matrix (<code>N=2</code>) for 2D imaging and a 3D tensor (<code>N=3</code>) for 3D imaging. The type of the elments <code>T</code> must match the ones of <code>λ</code>.</li><li><code>λ::Array{T,N}</code>: Toeplitz kernel, which as to be the same type as <code>x</code>, but twice the size due to the required oversampling (cf. <a href="#NFFT.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, Matrix{T}}, Tuple{Any, Matrix{T}, Any}, Tuple{Any, Matrix{T}, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any}, Tuple{Any, Matrix{T}, Any, Any, Any, Any}} where T"><code>calculateToeplitzKernel</code></a>).</li></ul><p><strong>Optional, but highly recommended Arguments</strong></p><ul><li><code>fftplan</code>: plan for the oversampled FFT, i.e. it has to have twice the size of the original image. Calculate, e.g., with <code>fftplan = plan_fft(λ; flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li><li><code>ifftplan</code>: plan for the oversampled inverse FFT. Calculate, e.g., with <code>ifftplan = plan_ifft(λ; flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li><li><code>xOS1</code>: pre-allocated array of the size of <code>λ</code>. Pre-allocate with <code>xOS1 = similar(λ)</code>.</li><li><code>xOS2</code>: pre-allocated array of the size of <code>λ</code>. Pre-allocate with <code>xOS2 = similar(λ)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using FFTW

julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(2, 1000) .- 0.5);

julia&gt; λ = calculateToeplitzKernel((Nx, Nx), trj);

julia&gt; xOS1 = similar(λ);

julia&gt; xOS2 = similar(λ);

julia&gt; fftplan = plan_fft(xOS1; flags=FFTW.MEASURE);

julia&gt; ifftplan = plan_ifft(xOS1; flags=FFTW.MEASURE);

julia&gt; x = randn(ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(x, λ, fftplan, ifftplan, xOS1, xOS2)
32×32 Matrix{ComplexF32}:
  -1803.8+1.63312im  -1561.82-752.754im  …  -647.761-229.904im
  1114.51+41.7063im  -264.876-662.938im      401.956+968.49im
 -1380.27-315.122im   33.9136+905.85im       -1109.6+698.732im
   505.66-254.45im   -1687.54+370.488im     -195.682+412.91im
  406.557+314.59im    1861.73+506.391im      1048.28+647.188im
 -1048.58+36.8265im   27.7886+439.139im  …   526.469+1575.94im
 -291.241+786.415im   565.874+231.098im      713.937-1226.66im
  177.944+926.04im    873.483+42.0362im      88.2286-748.885im
  160.151-510.168im  -1039.33-1249.35im      1468.72-459.773im
 -857.312-441.418im   1077.05+1000.54im     -774.294-1822.92im
         ⋮                               ⋱
 -801.172+508.445im   497.832+1877.24im     -267.744-770.01im
 -513.894+153.35im    855.736+199.721im      1342.16+121.227im
  1125.26-863.306im   753.793+1884.79im  …  -401.419+1074.31im
   900.01+153.858im  -188.444-534.829im      1220.38-557.301im
   175.36-1445.92im   1968.61-3329.79im     -715.639-378.965im
  292.267+195.924im  -184.499-858.438im     -1513.19-513.17im
  477.721-1154.86im   156.387+1108.32im      8.60736-123.34im
  653.422+427.798im  -31.5388+570.621im  …  -871.204+89.9642im
   1441.1+194.813im   889.465-225.068im      1248.81+1110.32im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/Toeplitz.jl#L164-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.ndft!-Union{Tuple{Tg}, Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{Tg}, AbstractArray{T, D}}} where {D, T, Tg}" href="#NFFT.ndft!-Union{Tuple{Tg}, Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{Tg}, AbstractArray{T, D}}} where {D, T, Tg}"><code>NFFT.ndft!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndft!(plan::NFFTPlan{D}, g::AbstractVector{Tg}, f::AbstractArray{T,D})</code></pre><p>Compute NDFT of input array <code>f</code> and store result in pre-allocated output array <code>g</code>. Both arrays must have the same size compatible with the NFFT <code>plan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NDFT.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.ndft-Union{Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{T, D}}} where {D, T}" href="#NFFT.ndft-Union{Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{T, D}}} where {D, T}"><code>NFFT.ndft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndft(plan::NFFTPlan{D}, f::AbstractArray{T,D})
ndft(x, f::AbstractArray, rest...; kwargs...)</code></pre><p>Non pre-allocated versions of NDFT; see <code>ndft!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NDFT.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.ndft_adjoint!-Union{Tuple{Tg}, Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{Tg, D}, AbstractVector{T}}} where {D, T, Tg}" href="#NFFT.ndft_adjoint!-Union{Tuple{Tg}, Tuple{T}, Tuple{D}, Tuple{NFFT.NFFTPlan{D}, AbstractArray{Tg, D}, AbstractVector{T}}} where {D, T, Tg}"><code>NFFT.ndft_adjoint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndft_adjoint!(plan::NFFTPlan{D}, g::AbstractArray{Tg,D}, fHat::AbstractVector)</code></pre><p>Compute adjoint NDFT of input vector <code>fHat</code> and store result in pre-allocated output array <code>g</code>. The input arrays must have sizes compatible with the NFFT <code>plan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NDFT.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.ndft_adjoint-Tuple{NFFT.NFFTPlan, AbstractVector}" href="#NFFT.ndft_adjoint-Tuple{NFFT.NFFTPlan, AbstractVector}"><code>NFFT.ndft_adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndft_adjoint(plan::NFFTPlan, fHat::AbstractVector)
ndft_adjoint(x, N, fHat::AbstractVector, rest...; kwargs...)</code></pre><p>Non pre-allocated versions of NDFT adjoint; see <code>ndft_adjoint!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NDFT.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.nfft!-Union{Tuple{T}, Tuple{DIM}, Tuple{D}, Tuple{NFFT.NFFTPlan{D, DIM, T}, AbstractArray, StridedArray}} where {D, DIM, T}" href="#NFFT.nfft!-Union{Tuple{T}, Tuple{DIM}, Tuple{D}, Tuple{NFFT.NFFTPlan{D, DIM, T}, AbstractArray, StridedArray}} where {D, DIM, T}"><code>NFFT.nfft!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    nfft!(p, f, fHat) -&gt; fHat</code></pre><p>Calculate the NFFT of <code>f</code> with plan <code>p</code> and store the result in <code>fHat</code>.</p><p>Both <code>f</code> and <code>fHat</code> must be complex arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/CpuNFFT.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.nfft-Union{Tuple{D}, Tuple{T}, Tuple{Any, AbstractArray{T, D}, Vararg{Any}}} where {T, D}" href="#NFFT.nfft-Union{Tuple{D}, Tuple{T}, Tuple{Any, AbstractArray{T, D}, Vararg{Any}}} where {T, D}"><code>NFFT.nfft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    nfft(x, f::AbstractArray{T,D}, rest...; device::Device=CPU, kwargs...)</code></pre><p>calculates the NFFT of the array <code>f</code> for the nodes contained in the matrix <code>x</code> The output is a vector of length M=<code>size(nodes,2)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NFFT.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.nfft-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{AbstractNFFTPlan{D, 0, T}, AbstractArray{U, D}, Vararg{Any}}} where {D, T, U}" href="#NFFT.nfft-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{AbstractNFFTPlan{D, 0, T}, AbstractArray{U, D}, Vararg{Any}}} where {D, T, U}"><code>NFFT.nfft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    nfft(p, f) -&gt; fHat</code></pre><p>For a <strong>non</strong>-directional <code>D</code> dimensional plan <code>p</code> this calculates the NFFT of a <code>D</code> dimensional array <code>f</code> of size <code>N</code>. <code>fHat</code> is a vector of length <code>M</code>. (<code>M</code> and <code>N</code> are defined in the plan creation)</p><p>For a <strong>directional</strong> <code>D</code> dimensional plan <code>p</code> both <code>f</code> and <code>fHat</code> are <code>D</code> dimensional arrays, and the dimension specified in the plan creation is affected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/Abstract.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.nfft_adjoint!-Tuple{NFFT.NFFTPlan, AbstractArray, StridedArray}" href="#NFFT.nfft_adjoint!-Tuple{NFFT.NFFTPlan, AbstractArray, StridedArray}"><code>NFFT.nfft_adjoint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    nfft_adjoint!(p, fHat, f) -&gt; f</code></pre><p>Calculate the adjoint NFFT of <code>fHat</code> and store the result in <code>f</code>.</p><p>Both <code>f</code> and <code>fHat</code> must be complex arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/CpuNFFT.jl#L213-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.nfft_adjoint-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}, Vararg{Any}}} where T" href="#NFFT.nfft_adjoint-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}, Vararg{Any}}} where T"><code>NFFT.nfft_adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    nfft_adjoint(x, N, fHat::AbstractArray{T,D}, rest...; device::Device=CPU, kwargs...)</code></pre><p>calculates the adjoint NFFT of the vector <code>fHat</code> for the nodes contained in the matrix <code>x</code>. The output is an array of size <code>N</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NFFT.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.nfft_adjoint-Union{Tuple{U}, Tuple{T}, Tuple{DIM}, Tuple{D}, Tuple{AbstractNFFTPlan{D, DIM, T}, AbstractArray{U}, Vararg{Any}}} where {D, DIM, T, U}" href="#NFFT.nfft_adjoint-Union{Tuple{U}, Tuple{T}, Tuple{DIM}, Tuple{D}, Tuple{AbstractNFFTPlan{D, DIM, T}, AbstractArray{U}, Vararg{Any}}} where {D, DIM, T, U}"><code>NFFT.nfft_adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    nfft_adjoint(p, fHat) -&gt; f</code></pre><p>For a <strong>non</strong>-directional <code>D</code> dimensional plan <code>p</code> this calculates the adjoint NFFT of a length <code>M</code> vector <code>fHat</code> <code>f</code> is a <code>D</code> dimensional array of size <code>N</code>. (<code>M</code> and <code>N</code> are defined in the plan creation)</p><p>For a <strong>directional</strong> <code>D</code> dimensional plan <code>p</code> both <code>f</code> and <code>fHat</code> are <code>D</code> dimensional arrays, and the dimension specified in the plan creation is affected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/Abstract.jl#L43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}" href="#NFFT.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}"><code>NFFT.plan_nfft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    plan_nfft(x::Matrix{T}, N::NTuple{D,Int}, rest...; device::Device=CPU, kargs...)</code></pre><p>compute a plan for the NFFT of a size-<code>N</code> array at the nodes contained in <code>x</code>.</p><p>The computing device (CPU or GPU) can be set using the keyworkd argument <code>device</code> to NFFT.CPU or NFFT.CUDAGPU</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NFFT.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Vector{T}, Integer, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}" href="#NFFT.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Vector{T}, Integer, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}"><code>NFFT.plan_nfft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    plan_nfft(x::Vector{T}, dim::Integer, N::NTuple{D,Int}, rest...; device::Device=CPU, kargs...)</code></pre><p>compute a plan for the NFFT of a size-<code>N</code> array at the nodes contained in <code>x</code> and along the direction <code>dim</code>. The computing device (CPU or GPU) can be set using the keyworkd argument <code>device</code>. Currently only NFFT.CPU is supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/NFFT.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.precomp_apodIdx-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Tuple{Vararg{Int64, D}}}} where D" href="#NFFT.precomp_apodIdx-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Tuple{Vararg{Int64, D}}}} where D"><code>NFFT.precomp_apodIdx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>precompute indices of the apodized image in the oversampled grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/precomputation.jl#L146-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.precomp_windowHatInvLUT-Union{Tuple{D}, Tuple{Type, Function, Tuple{Vararg{Int64, D}}, Real, Int64}} where D" href="#NFFT.precomp_windowHatInvLUT-Union{Tuple{D}, Tuple{Type, Function, Tuple{Vararg{Int64, D}}, Real, Int64}} where D"><code>NFFT.precomp_windowHatInvLUT</code></a> — <span class="docstring-category">Method</span></header><section><div><p>precompute LUT for the multidimensional interpolation window</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tknopp/NFFT.jl/blob/b4cb9d501e8374716041a4671c3587fb6ddc4a98/src/precomputation.jl#L120-L122">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../density/">« Density</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 January 2022 22:37">Saturday 1 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
