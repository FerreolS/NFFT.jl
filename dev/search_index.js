var documenterSearchIndex = {"docs":
[{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Basic usage of NFFT.jl is shown in the following example for 1D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using NFFT\n\nM, N = 1024, 512\nx = range(-0.4, stop=0.4, length=M)  # nodes at which the NFFT is evaluated\nfHat = randn(ComplexF64,M)           # data to be transformed\np = plan_nfft(x, N)                  # create plan. m and sigma are optional parameters\nf = nfft_adjoint(p, fHat)            # calculate adjoint NFFT\ng = nfft(p, f)                       # calculate forward NFFT","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In 2D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M, N = 1024, 16\nx = rand(2, M) .- 0.5\nfHat = randn(ComplexF64,M)\np = plan_nfft(x, (N,N))\nf = nfft_adjoint(p, fHat)\ng = nfft(p, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the eltype of the arguments f and fHat must be compatible that of the variable x used in the plan_nfft call. For example, if one wants to use Float32 types to save memory, then one can make the plan using something like this:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x = Float32.(LinRange(-0.5,0.5,64))\np = plan_nfft(x, N)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The plan will then internally use Float32 types. Then the arguments f and fHat above should have eltype Complex{Float32} or equivalently ComplexF32, otherwise there will be error messages.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"One can also perform NFFT computations directly without first creating a plan:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"g = nfft(x, f)\nf = nfft_adjoint(x, N, fHat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"These forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same x","category":"page"},{"location":"density/#Sampling-Density","page":"Density","title":"Sampling Density","text":"","category":"section"},{"location":"density/","page":"Density","title":"Density","text":"TODO","category":"page"},{"location":"#NFFT.jl","page":"Home","title":"NFFT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the Non-equidistant Fast Fourier Transform","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the Non-equidistant Fast Fourier Transform (NFFT). For a detailed introduction into the NFFT and its application please have a look at www.nfft.org.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT is a fast implementation of the Non-equidistant Discrete Fourier Transform (NDFT) that is basically a DFT with non-equidistant sampling nodes in either Fourier or time/space domain. In contrast to the FFT, the NFFT is an approximative algorithm whereas the accuracy can be controlled by two parameters: the window width m and the oversampling factor sigma.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add NFFT","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the packages NFFT.jl and all its dependencies.","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tobias Knopp","category":"page"},{"location":"directional/#Directional-NFFT","page":"Directional","title":"Directional NFFT","text":"","category":"section"},{"location":"directional/","page":"Directional","title":"Directional","text":"There are special methods for computing 1D NFFT's for each 1D slice along a particular dimension of a higher dimensional array.","category":"page"},{"location":"directional/","page":"Directional","title":"Directional","text":"M = 11\ny = rand(M) .- 0.5\nN = (16,20)\nP1 = plan_nfft(y, 1, N)\nf = randn(ComplexF64,N)\nfHat = nfft(P1, f)","category":"page"},{"location":"directional/","page":"Directional","title":"Directional","text":"Here size(f) = (16,20) and size(fHat) = (11,20) since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension","category":"page"},{"location":"directional/","page":"Directional","title":"Directional","text":"P2 = plan_nfft(y, 2, N)\nfHat = nfft(P2, f)","category":"page"},{"location":"directional/","page":"Directional","title":"Directional","text":"Now size(fHat) = (16,11).","category":"page"}]
}
