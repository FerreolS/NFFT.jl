var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Author = \"Tobias Knopp and contributors\"\nCurrentModule = NFFT","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of some, and hopefully soon all, exported functions of the NFFT.jl package:","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NFFT]","category":"page"},{"location":"api/#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{Array}, Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.plan_nfft","text":"    plan_nfft(x::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)\n\ncompute a plan for the NFFT of a size-N array at the nodes contained in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan, Matrix{T}, Any}} where T","page":"API","title":"NFFT.calculateToeplitzKernel!","text":"calculateToeplitzKernel!(f::Array{Complex{T}}, p::AbstractNFFTPlan, tr::Matrix{T}, fftplan)\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure and writes it in-place in f, which has to be twice the size of the desired image matrix, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel f has to be Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiecy, call this function with Float32.(tr), and set the type of f accordingly.\n\nRequired Arguments\n\nf::Array{T}: Array in which the kernel will be written.\np::AbstractNFFTPlan: NFFTPlan with the same dimentions as tr, which will be overwritten in place.\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\nfftplan: plan for the final FFT of the Kernal from image to k-space. Therefore, it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\n\nExamples\n\njulia> using FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> p = plan_nfft(trj, (2Nx,2Nx))\nNFFTPlan with 1000 sampling points for (64, 64) array\n\njulia> fftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=FFTW.MEASURE);\n\njulia> λ = Array{ComplexF32}(undef, 2Nx, 2Nx);\n\njulia> calculateToeplitzKernel!(λ, p, trj, fftplan);\n\njulia> x = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(x, λ);\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, Matrix{T}}} where T","page":"API","title":"NFFT.calculateToeplitzKernel","text":"calculateToeplitzKernel(shape, tr::Matrix{T}[; m = 4, σ = 2.0, window = :kaiser_bessel, LUTSize = 2000, fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE), kwargs...])\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure. The output is an array of twice the size of shape, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel is Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiecy, call this function with Float32.(tr), and the kernel will also be Float32.\n\nRequired Arguments\n\nshape::NTuple(Int): size of the image; e.g. (256, 256) for 2D imaging, or (256,256,128) for 3D imaging\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\n\nOptional Arguments:\n\nm::Int: nfft kernel size (used to calculate the Toeplitz kernel); default = 4\nσ::Number: nfft oversampling factor during the calculation of the Toeplitz kernel; default = 2\nwindow::Symbol: Window function of the nfft (c.f. getWindow); default = :kaiser_bessel\nK::Int: default= 2000 # TODO: describe meaning of k\n\nKeyword Arguments:\n\nfftplan: plan for the final FFT of the Kernal from image to k-space. Therefore, it has to have twice the size of the original image. default = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE). If this constructor is used many times, it is worth to precompute the plan with plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE) and reuse it.\nkwargs: Passed on to plan_fft! via NFFTPlan; can be used to modify the flags flags=FFTW.ESTIMATE, timelimit=Inf.\n\nExamples\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj)\n64×64 Matrix{ComplexF32}:\n  1697.69+483.218im   -147.57-257.719im  …   604.041-479.841im\n  1858.23-220.871im   3723.91-4.62838im      3917.46+217.494im\n  3260.49+249.208im   1719.05-23.7088im      1935.48-245.831im\n  1115.56-210.368im  -85.7251-15.1312im      499.092+206.991im\n  3232.19+666.149im  -927.182-440.649im      1048.98-662.772im\n -2818.12-640.593im   2892.04+415.094im  …   -435.71+637.216im\n  3019.67+377.944im   1978.27-152.445im      4267.19-374.567im\n  711.755-499.0im     11091.8+273.5im        822.519+495.623im\n -436.376+576.158im   2085.76-350.659im      280.188-572.781im\n -460.382-658.799im  -402.648+433.299im      1579.94+655.422im\n         ⋮                               ⋱\n  863.552-940.384im  -571.564+714.885im  …   325.992+937.007im\n  -554.64+283.37im   -416.581-57.8705im     -295.217-279.993im\n  680.462-381.469im   437.636+155.97im       381.239+378.092im\n -1769.07+404.678im   291.916-179.179im      192.257-401.301im\n  1502.99-212.153im   3114.76-13.346im       3939.76+208.776im\n  1192.88+274.105im   728.321-48.6058im  …   593.152-270.728im\n  318.763-370.158im  -273.715+144.659im     -323.591+366.781im\n -810.074+257.924im  -144.068-32.4241im      -44.218-254.546im\n  6650.49-187.076im  -1154.77-38.4236im      1493.98+183.699im\n\njulia> x = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(x, λ)\n32×32 Matrix{ComplexF32}:\n -2548.17+350.061im  -83.5555-1118.35im  …  -369.412+1283.74im\n -232.842+353.766im   950.106+2080.18im     -598.713-944.801im\n -1009.52-1121.52im    93.405+693.621im      1390.72+197.977im\n  1812.78-9.56223im   275.549+599.843im      458.824-1033.59im\n -1213.11-163.169im  -329.302-1185.4im       356.961-1026.23im\n  1479.05-1515.57im   1149.94-1208.13im  …   410.585+209.635im\n  1021.91+1114.42im   571.518+509.203im     -1047.46+647.597im\n -12.9759+900.257im   880.053+758.609im     -1017.49-1609.38im\n  398.851+171.48im     830.65+1170.5im       1277.94-2639.44im\n  188.979+789.158im   415.594+370.381im       101.68-1864.72im\n         ⋮                               ⋱\n  -1458.0-1250.08im   2466.35+374.447im     -352.156+306.172im\n  828.511-333.487im   2105.72+344.53im      -401.738-782.178im\n -602.072-108.482im  -1368.96+1090.78im  …  -129.634-1951.61im\n  169.226-1887.22im   1637.13-460.677im      1077.74+775.838im\n  593.828+1301.49im  -1322.09+194.759im     -1700.84+531.625im\n  775.017-208.648im    1361.0-528.349im     -434.659+206.32im\n  1044.89-874.581im  -286.478+795.039im     -1186.11+879.18im\n -665.938+1052.24im   -34.669-1059.52im  …   -1700.0-1452.94im\n -303.172-1110.12im   2510.89+163.711im     -500.883-1606.86im\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}","page":"API","title":"NFFT.convolveToeplitzKernel!","text":"convolveToeplitzKernel!(x::Array{T,N}, λ::Array{T,N}[, fftplan = plan_fft(λ; flags=FFTW.ESTIMATE), ifftplan = plan_ifft(λ; flags=FFTW.ESTIMATE), xOS1 = similar(λ), xOS2 = similar(λ)])\n\nConvolves the image x with the Toeplitz kernel λ and overwrites x with the result. x is also returned for convenience. As this function is commonly applied many times, it is highly recommened to pre-allocate / pre-compute all optional arguments. By doing so, this entire function is non-allocating.\n\nRequired Arguments\n\nx::Array{T,N}: Input image that will be overwritten with the result. x is a matrix (N=2) for 2D imaging and a 3D tensor (N=3) for 3D imaging. The type of the elments T must match the ones of λ.\nλ::Array{T,N}: Toeplitz kernel, which as to be the same type as x, but twice the size due to the required oversampling (cf. calculateToeplitzKernel).\n\nOptional, but highly recommended Arguments\n\nfftplan: plan for the oversampled FFT, i.e. it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nifftplan: plan for the oversampled inverse FFT. Calculate, e.g., with ifftplan = plan_ifft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nxOS1: pre-allocated array of the size of λ. Pre-allocate with xOS1 = similar(λ).\nxOS2: pre-allocated array of the size of λ. Pre-allocate with xOS2 = similar(λ).\n\nExamples\n\njulia> using FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj);\n\njulia> xOS1 = similar(λ);\n\njulia> xOS2 = similar(λ);\n\njulia> fftplan = plan_fft(xOS1; flags=FFTW.MEASURE);\n\njulia> ifftplan = plan_ifft(xOS1; flags=FFTW.MEASURE);\n\njulia> x = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(x, λ, fftplan, ifftplan, xOS1, xOS2)\n32×32 Matrix{ComplexF32}:\n  -1803.8+1.63312im  -1561.82-752.754im  …  -647.761-229.904im\n  1114.51+41.7063im  -264.876-662.938im      401.956+968.49im\n -1380.27-315.122im   33.9136+905.85im       -1109.6+698.732im\n   505.66-254.45im   -1687.54+370.488im     -195.682+412.91im\n  406.557+314.59im    1861.73+506.391im      1048.28+647.188im\n -1048.58+36.8265im   27.7886+439.139im  …   526.469+1575.94im\n -291.241+786.415im   565.874+231.098im      713.937-1226.66im\n  177.944+926.04im    873.483+42.0362im      88.2286-748.885im\n  160.151-510.168im  -1039.33-1249.35im      1468.72-459.773im\n -857.312-441.418im   1077.05+1000.54im     -774.294-1822.92im\n         ⋮                               ⋱\n -801.172+508.445im   497.832+1877.24im     -267.744-770.01im\n -513.894+153.35im    855.736+199.721im      1342.16+121.227im\n  1125.26-863.306im   753.793+1884.79im  …  -401.419+1074.31im\n   900.01+153.858im  -188.444-534.829im      1220.38-557.301im\n   175.36-1445.92im   1968.61-3329.79im     -715.639-378.965im\n  292.267+195.924im  -184.499-858.438im     -1513.19-513.17im\n  477.721-1154.86im   156.387+1108.32im      8.60736-123.34im\n  653.422+427.798im  -31.5388+570.621im  …  -871.204+89.9642im\n   1441.1+194.813im   889.465-225.068im      1248.81+1110.32im\n\n\n\n\n\n\n","category":"method"},{"location":"performance/#Accuracy-and-Performance","page":"Performance","title":"Accuracy and Performance","text":"","category":"section"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Standard","page":"Overview","title":"Standard","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Basic usage of NFFT.jl is shown in the following example for 1D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using NFFT\n\nM, N = 1024, 512\nx = range(-0.4, stop=0.4, length=M)  # nodes at which the NFFT is evaluated\nfHat = randn(ComplexF64,M)           # data to be transformed\np = plan_nfft(x, N)                  # create plan. m and σ are optional parameters\nf = nfft_adjoint(p, fHat)            # calculate adjoint NFFT\ng = nfft(p, f)                       # calculate forward NFFT","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In 2D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M, N = 1024, 16\nx = rand(2, M) .- 0.5\nfHat = randn(ComplexF64,M)\np = plan_nfft(x, (N,N))\nf = nfft_adjoint(p, fHat)\ng = nfft(p, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the eltype of the arguments f and fHat must be compatible that of the variable x used in the plan_nfft call. For example, if one wants to use Float32 types to save memory, then one can make the plan using something like this:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x = Float32.(LinRange(-0.5,0.5,64))\np = plan_nfft(x, N)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The plan will then internally use Float32 types. Then the arguments f and fHat above should have eltype Complex{Float32} or equivalently ComplexF32, otherwise there will be error messages.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"One can also perform NFFT computations directly without first creating a plan:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"g = nfft(x, f)\nf = nfft_adjoint(x, N, fHat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"These forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same x","category":"page"},{"location":"overview/#Directional","page":"Overview","title":"Directional","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are special methods for computing 1D NFFT's for each 1D slice along a particular dimension of a higher dimensional array.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M = 11\ny = rand(M) .- 0.5\nN = (16,20)\nP1 = plan_nfft(y, 1, N)\nf = randn(ComplexF64,N)\nfHat = nfft(P1, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here size(f) = (16,20) and size(fHat) = (11,20) since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"P2 = plan_nfft(y, 2, N)\nfHat = nfft(P2, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now size(fHat) = (16,11).","category":"page"},{"location":"gpu/#GPU-Support","page":"GPU","title":"GPU Support","text":"","category":"section"},{"location":"#NFFT.jl","page":"Home","title":"NFFT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the Non-equidistant Fast Fourier Transform","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the Non-equidistant Fast Fourier Transform (NFFT). For a detailed introduction into the NFFT and its application please have a look at www.nfft.org.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT is a fast implementation of the Non-equidistant Discrete Fourier Transform (NDFT) that is basically a DFT with non-equidistant sampling nodes in either Fourier or time/space domain. In contrast to the FFT, the NFFT is an approximative algorithm whereas the accuracy can be controlled by two parameters: the window width m and the oversampling factor σ.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add NFFT","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the packages NFFT.jl and all its dependencies.","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tobias Knopp\nRobert Dahl Jacobsen\nMirco Grosser\nJakob Assländer\nMosè Giordano","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete list of contributors can be found on the Github page.","category":"page"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/#Sampling-Density","page":"Tools","title":"Sampling Density","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"TODO","category":"page"},{"location":"tools/#Toeplitz-Kernel","page":"Tools","title":"Toeplitz Kernel","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"TODO","category":"page"}]
}
