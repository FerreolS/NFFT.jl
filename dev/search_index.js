var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Author = \"Tobias Knopp and contributors\"\nCurrentModule = NFFT","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of some, and hopefully soon all, exported functions of the NFFT.jl package family:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractNFFTs.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs]","category":"page"},{"location":"api/","page":"API","title":"API","text":"NFFT.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NFFT]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs,NFFT]","category":"page"},{"location":"api/#AbstractNFFTs.AbstractNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNFFTPlan","text":"AbstractNFFTPlan{T,D,R}\n\nAbstract type for an NFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNNFFTPlan","text":"AbstractNNFFTPlan{T,D,R}\n\nAbstract type for an NNFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AnyNFFTPlan","page":"API","title":"AbstractNFFTs.AnyNFFTPlan","text":"AnyNFFTPlan{T,D,R}\n\nAbstract type for either an NFFT plan or an NNFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.accuracyParams-Tuple{}","page":"API","title":"AbstractNFFTs.accuracyParams","text":"accuracyParams(; [m, σ, reltol]) -> m, σ, reltol\n\nCalculate accuracy parameters m, σ, reltol based on either\n\nreltol\n\nor\n\nm, σ\n\nTODO: Right now, the oversampling parameter is not taken into account, i.e. σ=2.0 is assumed\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft-Union{Tuple{D}, Tuple{T}, Tuple{Any, AbstractArray{T, D}}} where {T, D}","page":"API","title":"AbstractNFFTs.nfft","text":"nfft(x, f::AbstractArray{T,D}, rest...; kwargs...)\n\ncalculates the NFFT of the array f for the nodes contained in the matrix x The output is a vector of length M=size(nodes,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}}} where T","page":"API","title":"AbstractNFFTs.nfft_adjoint","text":"nfft_adjoint(x, N, fHat::AbstractArray{T,D}, rest...; kwargs...)\n\ncalculates the adjoint NFFT of the vector fHat for the nodes contained in the matrix x. The output is an array of size N\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractNFFTPlan{T}, Matrix{T}}} where T","page":"API","title":"AbstractNFFTs.nodes!","text":"nodes!(p, x) -> p\n\nChange nodes x in the plan p operation and return the plan.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_in-Union{Tuple{AbstractNFFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_in","text":"size_in(p)\n\nSize of the input array for an NFFT operation. The returned tuple has D entries.  Note that this will be the output array for an adjoint NFFT.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_out-Union{Tuple{AbstractNFFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_out","text":"size_out(p)\n\nSize of the output array for an NFFT operation. The returned tuple has R entries.  Note that this will be the input array for an adjoint NFFT.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AnyNFFTPlan{T}, AbstractArray{Complex{U}, D}}} where {T, U, D}","page":"API","title":"Base.:*","text":"    *(p, f) -> fHat\n\nFor a non-directional D dimensional plan p this calculates the NFFT of a D dimensional array f of size N. fHat is a vector of length M. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, AbstractNFFTPlan{T}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(fHat, p, f) -> fHat\n\nInplace NFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Adjoint{Complex{T}, <:AnyNFFTPlan{T}}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(f, p, fHat) -> f\n\nInplace adjoint NFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{<:Array}, Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.plan_nfft","text":"    plan_nfft(x::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)\n\ncompute a plan for the NFFT of a size-N array at the nodes contained in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.precomputeLUT-NTuple{6, Any}","page":"API","title":"NFFT.precomputeLUT","text":"Precompute the look up table for the window function φ.\n\nRemarks: \n\nOnly the positive half is computed\nThe window is computed for the interval [0, (m+2)/n]. The reason for the +2 is that we do evaluate the window function outside its interval, since x does not  necessary match the sampling points\nThe window has K+1 entries and during the index calculation we multiply with the  factor K/(m+2).\nIt is very important that K/(m+2) is an integer since our index calculation exploits this fact. We therefore always use Int(K/(m+2))instead of K÷(m+2) since this gives an error while the later variant would silently error.\n\n\n\n\n\n","category":"method"},{"location":"performance/#Accuracy-and-Performance","page":"Performance","title":"Accuracy and Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"On this page, the accuracy and the performance of NFFT.jl are investigated. For comparison we use the C library NFFT3 and the C++ library FINUFFT. The shown data are useful for understanding the performance characteristics of the NFFT and help choosing the parameters accordingly.","category":"page"},{"location":"performance/#Accuracy","page":"Performance","title":"Accuracy","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We start with the accuracy. The following plot shows the relative error of a 2D NFFT (N=(6464) M=64^2) compared to the NDFT for different choices of m and sigma = 2:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: Accurracy)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"What can be seen is that the error decreases exponentially with both parameters. For about m=8 and sigma = 2, the error reaches the machine precision and the NFFT then can be considered to be exact in floating point arithmetics.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"In practice, however, one often uses Float32 instead of Float64 in which case both parameters can be chosen much smaller. Even when using sigma = 125 and m = 4 one often has more than enough accuracy if the reconstructed image is considered to be an image with gray values, since the human eye can only discriminate about three orders of magnitude in gray values.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"One can also see that independent implementations reach very similar accuracy. The accuracy for FINUFFT is a little bit higher, which might be due to the different window function being used.","category":"page"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Next, we investigate the performance of the NFFT and benchmark the following three operations:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"pre-computation of the plan\nforward NFFT\nadjoint NFFT","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"The parameters for the benchmark are ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"N=(6464)\nM=64^2\nm=4\nsigma = 2\n1, 2, 4, 8 and 16 threads\nsorted random nodes","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"All benchmarks are performed with @belapsed from BenchmarkTools.jl which takes the minimum of several runs (10 s upper benchmark time). The benchmark is run on a computer with 2 AMD EPYC 7702 CPUs running at 2.0 GHz (256 cores in total) and a main memory of 1024 GB. The benchmark suite is described here.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"The results are shown in the following graphic","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: Performance Multi-threaded)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Observations:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"All packages are within a factor of about three \nThey are properly multi-threaded and scale with the number of threads\nNFFT3 was benchmarked with LUT (parameter PRE_PSI_LUT in NFFT3) and TENSOR (NFFT3: PRE_PSI), the later being the default option. This is because the one has much shorter precomputation time while the other is faster\nNFFT.jl and FINUFFT are very close to each other.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"note: Note\nThe results for FINUFFT include the precomputation time within the forward/adjoint NFFT. The reason is that it is currently not possible to create and store two independent plans with FINUFFT and in turn caching of the plan cannot be exploited in the common scenario where the forward and the adjoint NFFT are used in pairs (i.e. within iterative solvers where multiplications with bmA^mathsfH bmW bmA are required). ","category":"page"},{"location":"abstract/#Abstract-Interface-for-NFFTs","page":"AbstractNFFTs","title":"Abstract Interface for NFFTs","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The package AbstractNFFTs provides the abstract interface for NFFT implementations. Defining an abstract interface has the advantage that different implementation can exist and be exchanged with  close to zero effort on the user side.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"An overview about the current packages and their dependencies is shown in the following package tree:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"(Image: Performance Multi-threaded)","category":"page"},{"location":"abstract/#Implementations","page":"AbstractNFFTs","title":"Implementations","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Right now there are three implementations:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"NFFT.jl: This is the reference implementation running und the cpu.\nCuNFFT.jl: An implementation running on graphics hardware of Nvidia exploiting CUDA.jl\nNFFT3.jl: In the Wrapper directory of NFFT.jl there is a wrapper around the NFFT3.jl package following the  AbstractNFFTs interface. NFFT3.jl is itself a wrapper around the high performance C library nfft3.\nFINUFFT.jl: In the Wrapper directory of NFFT.jl there is a wrapper around the FINUFFT.jl package. FINUFFT.jl is itself a wrapper around the high performance C++ library FINUFFT.","category":"page"},{"location":"abstract/#Interface","page":"AbstractNFFTs","title":"Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"An NFFT implementation needs to define a new type that is a subtype of AbstractNFFTPlan{T,D,R}. Here","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"T is the real-valued element type of the nodes, i.e. a transform the operates on Complex{Float64} values and has Float64 nodes uses the type T=Float64 here.\nD is the size of the input vector\nR is the size of the output vector. Usually this will be R=1 unless a directional NFFT is implemented.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"For instance the CuNFFTPlan is defined like this","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"mutable struct CuNFFTPlan{T,D} <: AbstractNFFTPlan{T,D,1} \n  ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"In addition to the plan, the following functions need to be implemented: ","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"size_out(p)\nsize_out(p)\nmul!(fHat, p, f) -> fHat\nmul!(f, p::Adjoint{Complex{T},<:AbstractNFFTPlan{T}}, fHat) -> f\nnodes!(p, x) -> p","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"All these functions are exported from AbstractNFFTs and we recommend to implement them by using the explicit AbstractNFFTs. prefix:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"function AbstractNFFTs.size_out(p:MyNFFTPlan)\n ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"We next outline all of the aforementioned functions and describe their behavior:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    size_in(p)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Size of the input array for an NFFT operation. The returned tuple has D entries.  Note that this will be the output array for an adjoint NFFT.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    size_out(p)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Size of the output array for an NFFT operation. The returned tuple has R entries.  Note that this will be the input array for an adjoint NFFT.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    mul!(fHat, p, f) -> fHat","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Inplace NFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    mul!(f, p::Adjoint{Complex{T},<:AbstractNFFTPlan{T}}, fHat) -> f","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Inplace adjoint NFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    nodes!(p, x)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Change nodes x in the plan p operation and return the plan. The implementation of this function is optional.","category":"page"},{"location":"abstract/#Plan-Interface","page":"AbstractNFFTs","title":"Plan Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The constructor for an plan also has a defined interface. It should be implemented in this way:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"function MyNFFTPlan(x::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {T,D}\n  ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"All parameters are put into keyword arguments that have to match as well. We describe the keyword arguments in more detail in the overview page.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Additionally, to the constructor an AbstractNFFTPlan implementation can provide the factory","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"plan_nfft(Q::Type, x::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {D}","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"where Q is the Array type, e.g. Array. The reason to require the array type is, that this allows for GPU implementations, which would use for instance CuArray here.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The package AbstractNFFTs provides a convenient constructor","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"plan_nfft(x::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {D}","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"defaulting to the Array type.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"note: Note\nDifferent packages implementing plan_nfft will conflict if the same Q is implemented. In case of NFFT.jl and CuNFFT.jl there is no conflict since the array type is different.","category":"page"},{"location":"abstract/#Derived-Interface","page":"AbstractNFFTs","title":"Derived Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The following derived functions are provided for all plans that inherit from AbstractNFFTPlan:","category":"page"},{"location":"abstract/#Non-preallocated-NFFT","page":"AbstractNFFTs","title":"Non-preallocated NFFT","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The following two functions allocate a fresh output vector an operate out of place","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"*(p, f) -> fHat\n*(adjoint(p), fHat) -> f","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"...The NFFT can also be considered as a matrix vector multiplication. Julia provides the interface","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"  *(A, x) -> b\n  mul!(b, A, x) -> b","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"for this. Both operations are implemented for any AbstractNFFTPlan. To obtain the adjoint on needs to apply adjoint(p) to the plan p before multiplication.","category":"page"},{"location":"abstract/#Non-preallocated-Plan","page":"AbstractNFFTs","title":"Non-preallocated Plan","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The following two functions perform an NFFT without a preallocated plan:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"nfft(x, f) -> fHat\nnfft_adjoint(x, N, fHat) -> f","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Note that N needs only be specified for the adjoint. The direct NFFT can derive it from f.","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Getting-Started","page":"Overview","title":"Getting Started","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Basic usage of NFFT.jl is shown in the following example for 1D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using NFFT\n\nM, N = 8, 16\nx = range(-0.4, stop=0.4, length=M)  # nodes at which the NFFT is evaluated\nfHat = randn(ComplexF64,M)           # data to be transformed\np = plan_nfft(x, N)                  # create plan. m and σ are optional parameters\nf = adjoint(p) * fHat                # calculate adjoint NFFT\ng = p * f                            # calculate forward NFFT","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In 2D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M, N = 16, 32\nx = rand(2, M) .- 0.5\nfHat = randn(ComplexF64,M)\np = plan_nfft(x, (N,N))\nf = adjoint(p) * fHat\ng = p * f","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the eltype of the arguments f and fHat must be compatible that of the variable x used in the plan_nfft call. For example, if one wants to use Float32 types to save memory, then one can make the plan using something like this:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x = Float32.(LinRange(-0.5,0.5,64))\np = plan_nfft(x, N)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The plan will then internally use Float32 types. Then the arguments f and fHat above should have eltype Complex{Float32} or equivalently ComplexF32, otherwise there will be error messages.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"One can also perform NFFT computations directly without first creating a plan:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"g = nfft(x, f)\nf = nfft_adjoint(x, N, fHat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"These forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same x","category":"page"},{"location":"overview/#Parameters","page":"Overview","title":"Parameters","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The NFFT has the following parameters that can be passed as a keyword argument to the constructor ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Parameter Description Example Values\nreltol Relative tolerance that the NFFT achieves. reltol =1e-9\nm Kernel size parameter. The convolution matrix has 2m+1 non-zero entries around each sampling node in each dimension. m in 2dots8\nσ Oversampling factor. The inner FFT is of size σN σ in 125 20\nwindow Convolution window: Available are :gauss,  :spline, :kaiser_bessel_rev, :kaiser_bessel. :kaiser_bessel\nprecompute Flag indicating the precomputation strategy for the convolution matrix LUT\nsortNodes Flag if the nodes should be sorted in a lexicographic way false\nstoreApodizationIdx Flag if the apodization indices should be stored. Currently this option is necessary on the GPU false\nfftflags flags passed to the inner AbstractFFT as flags. This can for instance be FFTW.MEASURE in order to optimize the inner FFT FFTW.ESTIMATE","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In practice you the default values are properly chosen. The only parameter you should car about is reltol. In case of memory issues you want to change m, and σ instead and use a small oversampling factor like 1.25.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The parameters reltol, m, and σ are linked to each other. Either pass reltol  which will automatically set m and σ, or set the later parameters which will set the reltol.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The relation between reltol, m, and σ depends on the window function and the NFFT implementation. We use the formula","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"w = 2m + 1 = leftlceil textlog_10 frac1textreltol rightrceil + 1","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"independently of the chosen window.","category":"page"},{"location":"overview/#Precomputation","page":"Overview","title":"Precomputation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are different pre-computation strategies available. Again you don't need to change this parameter since the default NFFT.LUT is the best choice in most situations. However, our GPU implementation requires NFFT.FULL and thus there sometimes is need to change this value. In addition, it allows NFFT researchers to enforce a certain precomputation strategy, which can be mandatory when comparing different implementations in benchmarks.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Value Description\nNFFT.LUT This option uses a look-up table to first sample the window function and later use linear interpolation during the actual convolution.\nNFFT.FULL This option precomputes the entire convolution matrix and stores it as a SparseMatrixCSC. This option requires more memory and the longest precomputation time. This allows simple GPU implementations see CuNFFT.\nNFFT.TENSOR This option calculates the window on demand but exploits the tensor structure for multi-dimensional plans. Hence, this option makes no approximation but reaches a similar performance as NFFT.LUT. This option is right now only available in the NFFT3 backend.","category":"page"},{"location":"overview/#Multi-Threading","page":"Overview","title":"Multi-Threading","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Most parts of NFFT are multi-threaded when running on the CPU. To this end, start Julia with the option","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia -t T","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where T it the number of desired threads. NFFT.jl will use all threads that are specified. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the NFFT.LUT is fully multi-threaded while NFFT.LUT is multi-threaded in the precomputation and forward transformation, while the adjoint is not yet multi-threaded.","category":"page"},{"location":"overview/#Directional","page":"Overview","title":"Directional","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are special methods for computing 1D NFFT's for each 1D slice along a particular dimension of a higher dimensional array.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M = 11\n\ny = rand(M) .- 0.5\nN = (16,20)\nP1 = plan_nfft(y, N, dims=1)\nf = randn(ComplexF64,N)\nfHat = P1 * f","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here size(f) = (16,20) and size(fHat) = (11,20) since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"P2 = plan_nfft(y, N, dims=2)\nfHat = P2 * f","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now size(fHat) = (16,11).","category":"page"},{"location":"background/#Mathematical-Background","page":"Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/#NDFT","page":"Background","title":"NDFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"We next define the non-equidistant discrete Fourier transform (NDFT) that corresponds to the ordinary DFT. Let bmN in (2mathbbN)^d with d in mathbbN be the dimension of the d-dimensional Fourier coefficients hatf_bmk k in I_bmN. It is defined on the index set","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"I_bmN = leftlbrace pmbk in mathbbZ^d -fracN_i2 leq bmk_i leq fracN_i2-1 i=12ldotsd rightrbrace","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"and thus represents the same data that would be considered for an ordinary DFT. The NDFT is  defined as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  \tf(bmx_j) = sum_ bmk in I_bmN hatf_bmk  mathrme^-2pimathrmibmkcdotbmx","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where bmx_j in mathbbT^d j=1dots M with M in mathbbN are the nonequidistant sampling nodes and mathbbT = 1212) is the torus and f is the d-dimensional trigonometric polynomial associated with the Fourier coefficients hatf_bmk.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The direct NDFT operator has an associated adjoint that can be formulated as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"\thatg_bmk = sum_j = 1^M f(bmx_j)  mathrme^2 pi mathrmi  bmk cdot bmx_j bmk in I_bmN","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"We note that in general the adjoint NDFT is not the inverse.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nThe indices in the index set I_bmN are centered around zero, which is the usual definition of the NFFT. In contrast the indices for the DFT usually run from 1dotsN_d. This means an fftshift needs to be applied to change from one representation to the other.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nIn the literature the NFFT has different names. Often it is called NUFFT, and in the MRI context gridding. The NFFT is sometimes divided into three types of which type 1 corresponds to the adjoint NFFT, type 2 corresponds to the direct NFFT and type 3 corresponds to the NNFFT that we discuss later. Further information on this alternative formulation can be found here. ","category":"page"},{"location":"background/#Matrix-Vector-Notation","page":"Background","title":"Matrix-Vector Notation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NDFT can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" bmf = bmA hatbmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"beginaligned\n bmf = left( f(bmx_j) right)_j=1^M in mathbbC^mathbfN \n hatbmf = left( hatf_bmk right)_bmk in I_mathbfN in mathbbC^M\n  bmA =  left( mathrme^2 pi mathrmi  bmk cdot bmx_j right)_j=1dotsM bmk in I_mathbfN in mathbbC^M times mathbfN\nendaligned","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The adjoint can than be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hatbmg = bmA^mathsfH  bmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where hatbmg in mathbbC^mathbfN.","category":"page"},{"location":"background/#NFFT","page":"Background","title":"NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is an approximative algorithm that realizes the NDFT in just cal O(N log N + M) steps where N = textprod(bmN). This is at the same level as the ordinary FFT with the exception that of the additional linear dependence on M which is unavoidable since all nodes need to be touched as least once.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT has two important parameters that influence its accuracy:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"the window width m in mathbbN\nthe oversampling factor sigma in mathbbR with sigma  1","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"From the later we can derive bmn = sigma bmN in (2mathbbN)^d. As the definition indicates, the oversampling factor sigma is usually adjusted such that bmn consists of even integers.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT now approximates bmAby the product of three matrices","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA approx bmB bmF bmD","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmF in mathbbC^mathbfntimes mathbfn is the regular DFT matrix.\nbmD in mathbbC^mathbfntimes mathbfN is a diagonal matrix that additionally includes zero filling and the fftshift. We call this the apodization matrix.\nbmB in mathbbC^M times mathbfn is a sparse matrix implementing the discrete convolution with a window function varphi. We call this the convolution matrix.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is based on the convolution theorem. It applies a convolution in the time/space domain, which is evaluated at equidistant sampling nodes. This convolution is then corrected in the Fourier space by division with the Fourier transform psi of varphi. The adjoint NFFT matrix approximates bmA^mathsfH by","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA^mathsfH approx bmD^mathsfH bmF^mathsfH  bmB^mathsfH ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Implementation-wise, the matrix-vector notation illustrates that the NFFT consists of three independent steps that are performed successively. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The multiplication with bmD is a scalar multiplication with the input-vector plus the shifting of data, which can be done inplace.\nThe FFT is done with a high-performance FFT library such as the FFTW.\nThe multiplication with bmB needs to run only over a subset of the indices and is the most challenging step.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Since in practice the multiplication with bmB is also the most expansive step, an NFFT library needs to pay special attention to optimizing it appropriately.","category":"page"},{"location":"background/#Directional-NFFT","page":"Background","title":"Directional NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"In many cases one not just needs to apply a single NFFT but needs to apply many on different data. This leads us to the directional NFFT. The directional NFFT is defined as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  \tf_bmljbmr = sum_ bmk in I_bmN_textsub hatf_bmlbmkbmr  mathrme^-2pimathrmibmkcdotbmx","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where now (bml bmk bmr) in I_mathbfN and bmN_textsub is a subset of bmN. The transform thus maps a D-dimensional tensor hatf_bmlbmkbmr to an R-dimensional tensor f_bmljbmr. bmN_textsub is thus a vector of length D-R+1 The indices bml and bmr can also have length zero. Thus, for R=1, the conventional NFFT arises as a special case of the directional.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nThe directional NFFT can also be considered to be a slicing of a tensor with subsequent application of a regular NFFT. But the aforementioned formulation can be used to implement a much more efficient algorithm than can be achieved with slicing.","category":"page"},{"location":"background/#NNDFT-/-NNFFT","page":"Background","title":"NNDFT / NNFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Under construction","category":"page"},{"location":"#NFFT.jl","page":"Home","title":"NFFT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the Non-equidistant Fast Fourier Transform","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the Non-equidistant Fast Fourier Transform (NFFT). For a detailed introduction into the NFFT and its application please have a look at www.nfft.org.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT is a fast implementation of the Non-equidistant Discrete Fourier Transform (NDFT) that is basically a DFT with non-equidistant sampling nodes in either Fourier or time/space domain. In contrast to the FFT, the NFFT is an approximative algorithm whereas the accuracy can be controlled by two parameters: the window width m and the oversampling factor σ.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT.jl project serves two different purposes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provide a package AbstractNFFTs.jl that allows to use any NFFT Julia package such as NFFT3.jl or FINUFFT.jl using the same interface\nProvide a high-performance, parallel reference implementation in pure Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add NFFT","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the packages NFFT.jl and all its dependencies. Most importantly it installs the abstract interface package AbstractNFFTs.jl, which NFFT.jl implements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional NFFT related tools can be obtained by adding the package NFFTTools.jl. If you need support for CUDA you also need to install the package CuNFFT.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In case you want to use an alternative NFFT implementation such as NFFT3.jl or FINUFFT.jl we provide wrapper types allowing to use them as AbstractNFFTs implementations. They can be used like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AbstractNFFTs\njulia> include(joinpath(dirname(pathof(AbstractNFFTs)), \"..\", \"..\", \"Wrappers\", \"FINUFFT.jl\"))\njulia> include(joinpath(dirname(pathof(AbstractNFFTs)), \"..\", \"..\", \"Wrappers\", \"NFFT3.jl\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"This requires that you first add the package you want to use. ","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation starts with the Mathematical Background that properly defines the NDFT, the NFFT and its directional variants. You might want to skip this part if you are familiar with the notation and concepts of the NFFT. \nThen, an Overview about the usage of the NFFT functions is given in a tutorial style manner.  \nIn the section about the Abstract Interface for NFFTs we outline how the package is divided into an interface package and implementation packages. This part is useful if you plan to use different NFFT implementations, e.g. one for the CPU and another for the GPU and would like to switch.\nThe section about Tools introduced some high-level functions that build upon the NFFT. For instance NFFT inversion is discussed in that section.\nThen, an overview about Accuracy and Performance is given.\nImplementation outlines some implementation details.\nFinally, the documentation contains an API index.","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find bugs or have ideas for improvements please use the issue tracker. For general questions please use the discussions section on Github.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tobias Knopp\nRobert Dahl Jacobsen\nMirco Grosser\nJakob Assländer\nMosè Giordano","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete list of contributors can be found on the Github page.","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"We next indicate some implementation details and design choices being made during  the developments of NFFT.jl","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The split into ... ","category":"page"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The packages AbstractNFFT.jl and NFFT.jl are on purpose kept small and focussed. Additional tooling that relates to the NFFT is offloaded into a package NFFTTools.jl. The later can also be used with NFFT3.jl or FINUFFT.jl.","category":"page"},{"location":"tools/#Sampling-Density","page":"Tools","title":"Sampling Density","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The first tool that NFFTTools.jl is the computation of the sampling density. To motivate this let us have a look at the normalized variant of the DFT matrix bmF. bmF is unitary, which means that","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":" bmF^mathsfH bmF = bmI ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"where bmI is the identity matrix. In other words, bmF^mathsfH is the inverse of bmF^mathsfH.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Now lets switch to the NFFT. Have you already wondered why we don't call the adjoint the inverse? Well its because in general we have","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":" bmA^mathsfH bmA neq bmI ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"In fact, for the NFFT the inverse is a much more complicated subject since the linear system bmA bmf = hatbmf can have one, no or many solutions since bmAcan be under- or over-determined.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The good news is that in most cases, where M approx N and no complete clustering of the sampling nodes, one can find a diagonal weighting matrix bmW = left( w_k right)_k=1^Msuch that","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":" bmA^mathsfH bmW bmA approx bmI ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The weights w_k can be considered to we quadrature weights that account for the area covered by the node bmx_k. ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"NFFTTools.jl provides the function sdc that takes an existing plan and calculated suitable density weights:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"weights = sdc(p, iters = 10)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The function implements the method proposed in Pipe & Menon, 1999. Mag Reson Med, 186, 179.","category":"page"},{"location":"tools/#Toeplitz-Kernel","page":"Tools","title":"Toeplitz Kernel","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The aforementioned matrix bmA^mathsfH bmW bmA arises when solving linear system of the form","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"bmA^mathsfH bmf = hatbmf","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"which can be done via the normal equation","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"bmA^mathsfH bmW bmA bmf = bmA^mathsfH bmW hatbmf","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The normal or Gram matrix bmA^mathsfH bmW bmA has a Toeplitz structure. For multidimensional NFFT is is a block Toeplitz matrix with Toeplitz blocks. A Toeplitz matrix (and its block variants) can be embedded into a circulant matrix of twice the size in each dimension. Circulant matrices however are known to be diagonalizable by ordinary FFTs. This means we can multiply with bmA^mathsfH bmW bmA by just two FFTs of size 2bmN, which is basically the same amount of NFFTs as are required for an NFFT-based calculation of matrix-vector products with bmA^mathsfH bmW bmA. But the important difference is that no convolution step is required for the Toeplitz-based approach. This can often lead to large speedups, which are in particular important when using the Gram matrix in iterative solvers  (paragraph needs references).","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"With NFFTTools.jl on can calculate the kernel required in the Toeplitz with the function calculateToeplitzKernel. Multiplications with the Gram matrix can than be done using the function calculateToeplitzKernel!. The following outlines a complete example for the usage of both functions:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using NFFT, NFFTTools\n\nNx = 32;\n\ntrj = Float32.(rand(2, 1000) .- 0.5);\np = plan_nfft(trj, (2Nx,2Nx));\n\nfftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=NFFT.FFTW.MEASURE);\n\nλ = Array{ComplexF32}(undef, 2Nx, 2Nx);\n\ncalculateToeplitzKernel!(λ, p, trj, fftplan);\n\nx = randn(ComplexF32, Nx, Nx);\nconvolveToeplitzKernel!(x, λ);","category":"page"}]
}
