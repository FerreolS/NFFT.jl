var documenterSearchIndex = {"docs":
[{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/#Sampling-Density","page":"Tools","title":"Sampling Density","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"TODO","category":"page"},{"location":"tools/#Toeplitz-Kernel","page":"Tools","title":"Toeplitz Kernel","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"TODO","category":"page"},{"location":"api/","page":"API","title":"API","text":"Author = \"Tobias Knopp and contributors\"\nCurrentModule = NFFT","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of some, and hopefully soon all, exported functions of the NFFT.jl package family:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractNFFTs.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs]","category":"page"},{"location":"api/","page":"API","title":"API","text":"NFFT.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NFFT]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs,NFFT]","category":"page"},{"location":"api/#AbstractNFFTs.AbstractNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNFFTPlan","text":"AbstractNFFTPlan{T,D,R}\n\nAbstract type for an NFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.nfft!-Union{Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray, AbstractArray}} where {T, D, R}","page":"API","title":"AbstractNFFTs.nfft!","text":"nfft!(p, f, fHat) -> fHat\n\nInplace NFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft-Union{Tuple{D}, Tuple{T}, Tuple{Any, AbstractArray{T, D}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.nfft","text":"nfft(x, f::AbstractArray{T,D}, rest...; kwargs...)\n\ncalculates the NFFT of the array f for the nodes contained in the matrix x The output is a vector of length M=size(nodes,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft-Union{Tuple{U}, Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray{U, D}, Vararg{Any}}} where {T, D, R, U}","page":"API","title":"AbstractNFFTs.nfft","text":"    nfft(p, f) -> fHat\n\nFor a non-directional D dimensional plan p this calculates the NFFT of a D dimensional array f of size N. fHat is a vector of length M. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint!-Union{Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray, AbstractArray}} where {T, D, R}","page":"API","title":"AbstractNFFTs.nfft_adjoint!","text":"nfft_adjoint!(p, fHat, f) -> f\n\nInplace adjoint NFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}, Vararg{Any}}} where T","page":"API","title":"AbstractNFFTs.nfft_adjoint","text":"nfft_adjoint(x, N, fHat::AbstractArray{T,D}, rest...; kwargs...)\n\ncalculates the adjoint NFFT of the vector fHat for the nodes contained in the matrix x. The output is an array of size N\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint-Union{Tuple{U}, Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray{U}, Vararg{Any}}} where {T, D, R, U}","page":"API","title":"AbstractNFFTs.nfft_adjoint","text":"    nfft_adjoint(p, fHat) -> f\n\nFor a non-directional D dimensional plan p this calculates the adjoint NFFT of a length M vector fHat f is a D dimensional array of size N. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractNFFTPlan{T}, Matrix{T}}} where T","page":"API","title":"AbstractNFFTs.nodes!","text":"nodes!(p, x)\n\nChange nodes x in the plan p operation and return the plan.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_in-Union{Tuple{AbstractNFFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_in","text":"size_in(p)\n\nSize of the input array for an nfft! operation. The returned tuple has D entries.  Note that this will be the output array for nfft_adjoint!.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_out-Union{Tuple{AbstractNFFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_out","text":"size_out(p)\n\nSize of the output array for an nfft! operation. The returned tuple has R entries.  Note that this will be the input array for nfft_adjoint!.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{Array}, Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.plan_nfft","text":"    plan_nfft(x::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)\n\ncompute a plan for the NFFT of a size-N array at the nodes contained in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan, Matrix{T}, Any}} where T","page":"API","title":"NFFT.calculateToeplitzKernel!","text":"calculateToeplitzKernel!(f::Array{Complex{T}}, p::AbstractNFFTPlan, tr::Matrix{T}, fftplan)\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure and writes it in-place in f, which has to be twice the size of the desired image matrix, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel f has to be Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiecy, call this function with Float32.(tr), and set the type of f accordingly.\n\nRequired Arguments\n\nf::Array{T}: Array in which the kernel will be written.\np::AbstractNFFTPlan: NFFTPlan with the same dimentions as tr, which will be overwritten in place.\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\nfftplan: plan for the final FFT of the Kernal from image to k-space. Therefore, it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\n\nExamples\n\njulia> using FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> p = plan_nfft(trj, (2Nx,2Nx))\nNFFTPlan with 1000 sampling points for an input array of size(64, 64) and an output array of size(1000,) with dims 1:2\n\njulia> fftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=FFTW.MEASURE);\n\njulia> λ = Array{ComplexF32}(undef, 2Nx, 2Nx);\n\njulia> calculateToeplitzKernel!(λ, p, trj, fftplan);\n\njulia> x = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(x, λ);\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, Matrix{T}}} where T","page":"API","title":"NFFT.calculateToeplitzKernel","text":"calculateToeplitzKernel(shape, tr::Matrix{T}[; m = 4, σ = 2.0, window = :kaiser_bessel, LUTSize = 2000, fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE), kwargs...])\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure. The output is an array of twice the size of shape, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel is Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiecy, call this function with Float32.(tr), and the kernel will also be Float32.\n\nRequired Arguments\n\nshape::NTuple(Int): size of the image; e.g. (256, 256) for 2D imaging, or (256,256,128) for 3D imaging\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\n\nOptional Arguments:\n\nm::Int: nfft kernel size (used to calculate the Toeplitz kernel); default = 4\nσ::Number: nfft oversampling factor during the calculation of the Toeplitz kernel; default = 2\nwindow::Symbol: Window function of the nfft (c.f. getWindow); default = :kaiser_bessel\nK::Int: default= 2000 # TODO: describe meaning of k\n\nKeyword Arguments:\n\nfftplan: plan for the final FFT of the Kernal from image to k-space. Therefore, it has to have twice the size of the original image. default = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE). If this constructor is used many times, it is worth to precompute the plan with plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE) and reuse it.\nkwargs: Passed on to plan_fft! via NFFTPlan; can be used to modify the flags flags=FFTW.ESTIMATE, timelimit=Inf.\n\nExamples\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj)\n64×64 Matrix{ComplexF32}:\n -432.209+297.833im    271.68-526.348im  …   3044.35+34.6322im\n  990.057-244.569im  -582.825+473.084im      45.7631-87.8965im\n  1922.01+223.525im   9248.63-452.04im       3649.78+108.941im\n -402.371-3.37619im   496.815+231.891im      322.646-329.089im\n -482.346-121.534im   559.756-106.981im      155.183+454.0im\n   3293.8+194.388im  -3361.43+34.1272im  …   2672.16-526.853im\n -936.331+172.246im   4394.11-400.762im     -1121.04+160.219im\n -135.828+169.448im   3509.17+59.0678im      3883.84-501.913im\n  395.143+158.638im   24.4377-387.153im       5731.3+173.827im\n  925.902-117.765im    2935.3+346.28im      -1414.12-214.701im\n         ⋮                               ⋱\n  2239.72-295.883im   490.442+524.399im  …   2028.84-36.5824im\n -1108.11+227.146im   24.7403-455.661im     -549.699+105.319im\n  1323.78+110.713im  -321.052+117.802im      651.944-443.178im\n -52.1597+288.0im    -326.042-516.516im       3619.1+44.4651im\n  1180.56+73.3666im  -26.1233+155.148im     -869.065-405.832im\n  3555.36+649.527im  -198.245-878.042im  …   1198.83-317.062im\n -368.958-177.954im  -360.343+406.469im     -1478.96-154.512im\n  4861.29+38.9623im   6082.55-267.478im      2519.09+293.503im\n  1022.55-185.869im   177.426+414.384im      3650.56-146.597im\n\njulia> x = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(x, λ)\n32×32 Matrix{ComplexF32}:\n  177.717-52.0493im   10.6059+20.7185im  …   746.131+330.005im\n -311.858+988.219im  -1216.83-1295.14im      410.732+751.925im\n -1082.27+872.968im   1023.97-1556.45im     -923.699+478.63im\n -999.035-525.161im  -1694.59-658.558im     -521.044+607.005im\n -342.999+1481.82im  -1729.18-2712.81im      56.5212+1394.81im\n -1187.65-1979.55im   1389.67+970.033im  …   2968.93-744.264im\n -666.533+485.511im  -1315.83+409.855im     -610.146+132.258im\n  1159.57+64.6059im  -299.169-569.622im      663.802+396.827im\n -795.112-1464.63im   -462.43+2442.77im     -1622.72+1701.27im\n -1047.67+31.5578im  -1127.65-936.043im      474.071+797.911im\n         ⋮                               ⋱\n  327.345+2191.71im  -904.635+558.786im     -1449.32-276.721im\n  -1047.2-71.362im    363.109+567.346im      -1974.0-2348.36im\n -1540.45+1661.77im   1175.75+1279.75im  …   1110.61+653.234im\n -526.832-435.297im  -265.021-2019.08im      68.5607-323.086im\n -1076.52-2719.16im  -477.005+2232.06im      -155.59-1275.66im\n  1143.76-735.966im  -380.489+2485.78im      1812.17-261.191im\n  1685.44-1243.29im   1911.16-1157.72im     -991.639-42.8214im\n  1054.11-1282.41im   66.9358-588.991im  …  -952.238+1026.35im\n -417.276-273.367im  -946.698+1971.77im     -890.339-882.05im\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}","page":"API","title":"NFFT.convolveToeplitzKernel!","text":"convolveToeplitzKernel!(x::Array{T,N}, λ::Array{T,N}[, fftplan = plan_fft(λ; flags=FFTW.ESTIMATE), ifftplan = plan_ifft(λ; flags=FFTW.ESTIMATE), xOS1 = similar(λ), xOS2 = similar(λ)])\n\nConvolves the image x with the Toeplitz kernel λ and overwrites x with the result. x is also returned for convenience. As this function is commonly applied many times, it is highly recommened to pre-allocate / pre-compute all optional arguments. By doing so, this entire function is non-allocating.\n\nRequired Arguments\n\nx::Array{T,N}: Input image that will be overwritten with the result. x is a matrix (N=2) for 2D imaging and a 3D tensor (N=3) for 3D imaging. The type of the elments T must match the ones of λ.\nλ::Array{T,N}: Toeplitz kernel, which as to be the same type as x, but twice the size due to the required oversampling (cf. calculateToeplitzKernel).\n\nOptional, but highly recommended Arguments\n\nfftplan: plan for the oversampled FFT, i.e. it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nifftplan: plan for the oversampled inverse FFT. Calculate, e.g., with ifftplan = plan_ifft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nxOS1: pre-allocated array of the size of λ. Pre-allocate with xOS1 = similar(λ).\nxOS2: pre-allocated array of the size of λ. Pre-allocate with xOS2 = similar(λ).\n\nExamples\n\njulia> using FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj);\n\njulia> xOS1 = similar(λ);\n\njulia> xOS2 = similar(λ);\n\njulia> fftplan = plan_fft(xOS1; flags=FFTW.MEASURE);\n\njulia> ifftplan = plan_ifft(xOS1; flags=FFTW.MEASURE);\n\njulia> x = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(x, λ, fftplan, ifftplan, xOS1, xOS2)\n32×32 Matrix{ComplexF32}:\n  177.717-52.0493im   10.6059+20.7185im  …   746.131+330.005im\n -311.858+988.219im  -1216.83-1295.14im      410.732+751.925im\n -1082.27+872.968im   1023.97-1556.45im     -923.699+478.63im\n -999.035-525.161im  -1694.59-658.558im     -521.044+607.005im\n -342.999+1481.82im  -1729.18-2712.81im      56.5212+1394.81im\n -1187.65-1979.55im   1389.67+970.033im  …   2968.93-744.264im\n -666.533+485.511im  -1315.83+409.855im     -610.146+132.258im\n  1159.57+64.6059im  -299.169-569.622im      663.802+396.827im\n -795.112-1464.63im   -462.43+2442.77im     -1622.72+1701.27im\n -1047.67+31.5578im  -1127.65-936.043im      474.071+797.911im\n         ⋮                               ⋱\n  327.345+2191.71im  -904.635+558.786im     -1449.32-276.721im\n  -1047.2-71.362im    363.109+567.346im      -1974.0-2348.36im\n -1540.45+1661.77im   1175.75+1279.75im  …   1110.61+653.234im\n -526.832-435.297im  -265.021-2019.08im      68.5607-323.086im\n -1076.52-2719.16im  -477.005+2232.06im      -155.59-1275.66im\n  1143.76-735.966im  -380.489+2485.78im      1812.17-261.191im\n  1685.44-1243.29im   1911.16-1157.72im     -991.639-42.8214im\n  1054.11-1282.41im   66.9358-588.991im  …  -952.238+1026.35im\n -417.276-273.367im  -946.698+1971.77im     -890.339-882.05im\n\n\n\n\n\n\n","category":"method"},{"location":"performance/#Accuracy-and-Performance","page":"Performance","title":"Accuracy and Performance","text":"","category":"section"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Standard","page":"Overview","title":"Standard","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Basic usage of NFFT.jl is shown in the following example for 1D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using NFFT\n\nM, N = 8, 16\nx = range(-0.4, stop=0.4, length=M)  # nodes at which the NFFT is evaluated\nfHat = randn(ComplexF64,M)           # data to be transformed\np = plan_nfft(x, N)                  # create plan. m and σ are optional parameters\nf = nfft_adjoint(p, fHat)            # calculate adjoint NFFT\ng = nfft(p, f)                       # calculate forward NFFT","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In 2D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M, N = 16, 32\nx = rand(2, M) .- 0.5\nfHat = randn(ComplexF64,M)\np = plan_nfft(x, (N,N))\nf = nfft_adjoint(p, fHat)\ng = nfft(p, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the eltype of the arguments f and fHat must be compatible that of the variable x used in the plan_nfft call. For example, if one wants to use Float32 types to save memory, then one can make the plan using something like this:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x = Float32.(LinRange(-0.5,0.5,64))\np = plan_nfft(x, N)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The plan will then internally use Float32 types. Then the arguments f and fHat above should have eltype Complex{Float32} or equivalently ComplexF32, otherwise there will be error messages.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"One can also perform NFFT computations directly without first creating a plan:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"g = nfft(x, f)\nf = nfft_adjoint(x, N, fHat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"These forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same x","category":"page"},{"location":"overview/#Directional","page":"Overview","title":"Directional","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are special methods for computing 1D NFFT's for each 1D slice along a particular dimension of a higher dimensional array.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M = 11\n\ny = rand(M) .- 0.5\nN = (16,20)\nP1 = plan_nfft(y, N, dims=1)\nf = randn(ComplexF64,N)\nfHat = nfft(P1, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here size(f) = (16,20) and size(fHat) = (11,20) since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"P2 = plan_nfft(y, N, dims=2)\nfHat = nfft(P2, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now size(fHat) = (16,11).","category":"page"},{"location":"background/#Mathematical-Background","page":"Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/#NDFT","page":"Background","title":"NDFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"We next define the non-equidistant discrete Fourier transform (NDFT) that corresponds to the ordinary DFT. Let bmN in (2mathbbN)^d with d in mathbbN be the dimension of the d-dimensional Fourier coefficients hatf_bmk k in I_bmN. It is defined on the index set","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"I_bmN coloneqq  pmbk in mathbbZ^d -fracN_i2 leq bmk_i leq fracN_i2-1 i=12ldotsd ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"and thus represents the same data the would be considered for an ordinary DFT. The NDFT is now defined as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  \tf(bmx_j) coloneqq sum_ bmk in I_bmN^d hatf_bmk  mathrme^-2pimathrmibmkcdotbmx","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where bmx_j in mathbbT^d j=1dots M with M in mathbbN are the nonequidistant sampling nodes and mathbbT = 1212) is the torus and f is the d-dimensional trigonometric polynomial associated with the Fourier coefficients hatf_bmk.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The direct NDFT operator has an associated adjoint that can be formulated as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"\thatg_bmk = sum_j = 1^M f(bmx_j)  mathrme^2 pi mathrmi  bmk cdot bmx_j bmk in I_bmN","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"We note that in general the adjoint NDFT is not the inverse.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nThe indices in the index set I_bmN are centered around zero, which is the usual definition of the NFFT. In contrast the indices for the DFT usually run from 1dotsN_d. This means an fftshift needs to be applied to change from one representation to the other.","category":"page"},{"location":"background/#Matrix-Vector-Notation","page":"Background","title":"Matrix-Vector Notation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NDFT can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" bmf = bmA hatbmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"beginaligned\n bmf = left( f(bmx_j) right)_j=1^M in mathbbC^mathbfN \n hatbmf = left( hatf_bmk right)_bmk in I_mathbfN in mathbbC^M\n  bmA =  left( mathrme^2 pi mathrmi  bmk cdot bmx_j right)_j=1dotsM bmk in I_mathbfN in mathbbC^M times mathbfN\nendaligned","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The adjoint can than be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hatbmg = bmA^mathsfH  bmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where hatbmg in mathbbC^mathbfN.","category":"page"},{"location":"background/#NFFT","page":"Background","title":"NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is an approximative algorithm that realizes the NDFT in just cal O(N log N + M) steps where N = textprod(bmN). This is at the same level as the ordinary FFT with the exception that of the additional linear dependence on M which is unavoidable since all nodes need to be touched as least once.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT has two important parameters that influence its accuracy:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"the window width m in mathbbN\nthe oversampling factor sigma in mathbbR with sigma  1","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"From the later we can derive bmn = sigma bmN in (2mathbbN)^d. As the definition indicates, the oversampling factor sigma is usually adjusted such that bmn consists of even integers.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT now approximates bmAby the product of three matrices","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA approx bmB bmF bmD","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmF in mathbbC^mathbfntimes mathbfn is the regular DFT matrix.\nbmD in mathbbC^mathbfntimes mathbfN is a diagonal matrix that additionally includes zero filling and the fftshift. We call this the apodization matrix.\nbmB in mathbbC^M times mathbfn is a sparse matrix implementing the discrete convolution with a window function varphi. We call this the convolution matrix.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is based on the convolution theorem. It applies a convolution in the time/space domain, which is evaluated at equidistant sampling nodes. This convolution is then corrected in the Fourier space by division with the Fourier transform psi of varphi. The adjoint NFFT matrix approximates bmA^mathsfH by","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA^mathsfH approx bmD^mathsfH bmF^mathsfH  bmB^mathsfH ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Implementation-wise, the matrix-vector notation illustrates that the NFFT consists of three independent steps that are performed successively. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The multiplication with bmD is a scalar multiplication with the input-vector plus the shifting of data, which can be done inplace.\nThe FFT is done with a high-performance FFT library such as the FFTW\nThe multiplication with bmB needs to run only over a subset of the indices and is the most challenging step.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Since in practice tha multiplication with bmB is also the most expansive step, an NFFT library needs to pay special attention to optimizing it appropriately.","category":"page"},{"location":"background/#Directional-NFFT","page":"Background","title":"Directional NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"In many cases one not just needs to apply a single NFFT but needs to apply many on different data. This leads us to the directional NFFT. ","category":"page"},{"location":"backends/#Backends","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"backends/#CPU","page":"Backends","title":"CPU","text":"","category":"section"},{"location":"backends/#GPU","page":"Backends","title":"GPU","text":"","category":"section"},{"location":"backends/#NFFT3","page":"Backends","title":"NFFT3","text":"","category":"section"},{"location":"#NFFT.jl","page":"Home","title":"NFFT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the Non-equidistant Fast Fourier Transform","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the Non-equidistant Fast Fourier Transform (NFFT). For a detailed introduction into the NFFT and its application please have a look at www.nfft.org.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT is a fast implementation of the Non-equidistant Discrete Fourier Transform (NDFT) that is basically a DFT with non-equidistant sampling nodes in either Fourier or time/space domain. In contrast to the FFT, the NFFT is an approximative algorithm whereas the accuracy can be controlled by two parameters: the window width m and the oversampling factor σ.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add NFFT","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the packages NFFT.jl and all its dependencies.  If you need support for CUDA you also need to install the package CuNFFT.jl","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find bugs or have ideas for improvements please use the issue tracker. For general questions please use the discussions section on Github.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tobias Knopp\nRobert Dahl Jacobsen\nMirco Grosser\nJakob Assländer\nMosè Giordano","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete list of contributors can be found on the Github page.","category":"page"}]
}
