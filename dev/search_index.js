var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Author = \"Tobias Knopp and contributors\"\nCurrentModule = NFFT","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of some, and hopefully soon all, exported functions of the NFFT.jl package family:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractNFFTs.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs]","category":"page"},{"location":"api/","page":"API","title":"API","text":"NFFT.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NFFT]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs,NFFT]","category":"page"},{"location":"api/#AbstractNFFTs.AbstractNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNFFTPlan","text":"AbstractNFFTPlan{T,D,R}\n\nAbstract type for an NFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.nfft!-Union{Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray, AbstractArray}} where {T, D, R}","page":"API","title":"AbstractNFFTs.nfft!","text":"nfft!(p, f, fHat) -> fHat\n\nInplace NFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft-Union{Tuple{D}, Tuple{T}, Tuple{Any, AbstractArray{T, D}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.nfft","text":"nfft(x, f::AbstractArray{T,D}, rest...; kwargs...)\n\ncalculates the NFFT of the array f for the nodes contained in the matrix x The output is a vector of length M=size(nodes,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft-Union{Tuple{U}, Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray{U, D}, Vararg{Any}}} where {T, D, R, U}","page":"API","title":"AbstractNFFTs.nfft","text":"    nfft(p, f) -> fHat\n\nFor a non-directional D dimensional plan p this calculates the NFFT of a D dimensional array f of size N. fHat is a vector of length M. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint!-Union{Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray, AbstractArray}} where {T, D, R}","page":"API","title":"AbstractNFFTs.nfft_adjoint!","text":"nfft_adjoint!(p, fHat, f) -> f\n\nInplace adjoint NFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}, Vararg{Any}}} where T","page":"API","title":"AbstractNFFTs.nfft_adjoint","text":"nfft_adjoint(x, N, fHat::AbstractArray{T,D}, rest...; kwargs...)\n\ncalculates the adjoint NFFT of the vector fHat for the nodes contained in the matrix x. The output is an array of size N\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint-Union{Tuple{U}, Tuple{R}, Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, R}, AbstractArray{U}, Vararg{Any}}} where {T, D, R, U}","page":"API","title":"AbstractNFFTs.nfft_adjoint","text":"    nfft_adjoint(p, fHat) -> f\n\nFor a non-directional D dimensional plan p this calculates the adjoint NFFT of a length M vector fHat f is a D dimensional array of size N. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractNFFTPlan{T}, Matrix{T}}} where T","page":"API","title":"AbstractNFFTs.nodes!","text":"nodes!(p, x) -> p\n\nChange nodes x in the plan p operation and return the plan.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_in-Union{Tuple{AbstractNFFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_in","text":"size_in(p)\n\nSize of the input array for an nfft! operation. The returned tuple has D entries.  Note that this will be the output array for nfft_adjoint!.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_out-Union{Tuple{AbstractNFFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_out","text":"size_out(p)\n\nSize of the output array for an nfft! operation. The returned tuple has R entries.  Note that this will be the input array for nfft_adjoint!.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{<:Array}, Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.plan_nfft","text":"    plan_nfft(x::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)\n\ncompute a plan for the NFFT of a size-N array at the nodes contained in x.\n\n\n\n\n\n","category":"method"},{"location":"performance/#Accuracy-and-Performance","page":"Performance","title":"Accuracy and Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Next, the accuracy and the performance of NFFT.jl is investigated. For comparison we use the well-tested and well-tuned C library NFFT3. The shown data are useful for understanding the performance characteristics of the NFFT and help choosing the parameters accordingly.","category":"page"},{"location":"performance/#Accuracy","page":"Performance","title":"Accuracy","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We start with the accuracy. The following plot shows the relative error of a 2D NFFT (N=(6464) M=64^2) compared to the NDFT for different choices of m and sigma:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: Accurracy)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"What can be seen is that the error decreases exponentially with both parameters. For about m=8 and sigma = 2, the error reaches the machine precision and the NFFT then can be considered to be exact in floating point arithmetics.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"In practice, however, one often uses Float32 instead of Float64 in which case both parameters can be chosen much smaller. Even when using sigma = 125 and m = 4 one often has more than enough accuracy if the reconstructed image is considered to be an image with gray values, since the human eye can only discriminate about three orders in magnitude in gray values.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"One can also see that the two independent implementations NFFT.jl and NFFT3 both reach very similar accuracy. For small m the accuracy seems to be slightly better for the NFFT3 but we have not tracked down the reason for this.","category":"page"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Next, we look at the performance of the NFFT. The next graphic shows the performance for","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"precomputation of the plan\nforward NFFT\nadjoint NFFT","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"All three are benchmarked for the NFFT.jl and the NFFT3 as well as for two precomputation strategies. The parameters for the benchmark are ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"N=(6464)\nM=64^2\nm=4\nsigma = 2\nsorted random nodes","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"All benchmarks are performed with @belapsed from BenchmarkTools.jl which takes the minimum of several runs (10 s upper benchmark time).","category":"page"},{"location":"performance/#Single-Threaded-Performance","page":"Performance","title":"Single-Threaded Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We start with single-threaded performance:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: Performance Serial)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Some observations:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Full precomputation can take a huge amount of time. This usually only pays off when doing several runs. LUT precomputation is negligible.\nFull precomputation is not always faster\nBoth libraries have similar performance.","category":"page"},{"location":"performance/#Multi-Threaded-Performance","page":"Performance","title":"Multi-Threaded Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We next look at the multi-threading performance for 1,2,4,8, and 16 threads. First we look at the LUT precomputation:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: Performance Multi-threaded)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Some observations:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"...","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: Performance Multi-threaded)","category":"page"},{"location":"abstract/#Abstract-Interface-for-NFFTs","page":"AbstractNFFTs","title":"Abstract Interface for NFFTs","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The package AbstractNFFTs provides the abstract interface for NFFT implementations. Defining an abstract interface has the advantage that different implementation can exist and be exchanged with  close to zero effort on the user side.","category":"page"},{"location":"abstract/#Implementations","page":"AbstractNFFTs","title":"Implementations","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Right now there are three implementations:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"NFFT.jl: This is the reference implementation running und the cpu.\nCuNFFT.jl: An implementation running on graphics hardware of Nvidia exploiting CUDA.jl\nNFFT3.jl: In the test directory of NFFT.jl there is a wrapper around the NFFT3.jl package following the  AbstractNFFTs interface. NFFT3.jl is itself a wrapper around the high performance C library nfft3.","category":"page"},{"location":"abstract/#Interface","page":"AbstractNFFTs","title":"Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"An NFFT implementation needs to define a new type that is a subtype of AbstractNFFTPlan{T,D,R}. Here","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"T is the real-valued element type of the nodes, i.e. a transform the operates on Complex{Float64} values and has Float64 nodes uses the type T=Float64 here.\nD is the size of the input vector\nR is the size of the output vector. Usually this will be R=1 unless a directional NFFT is implemented.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"For instance the CuNFFTPlan is defined like this","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"mutable struct CuNFFTPlan{T,D} <: AbstractNFFTPlan{T,D,1} \n  ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"In addition to the plan, the following functions need to be implemented: ","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"size_out(p)\nsize_out(p)\nnfft!(p, f, fHat) -> fHat\nnfft_adjoint!(p, fHat, f) -> f\nnodes!(p, x) -> p","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"All these functions are exported from AbstractNFFTs and we recommend to implement them by using the explicit AbstractNFFTs. prefix:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"function AbstractNFFTs.size_out(p:MyNFFTPlan)\n ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"We next outline all of the aforementioned functions and describe their behavior:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    size_in(p)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Size of the input array for an nfft! operation. The returned tuple has D entries.  Note that this will be the output array for nfft_adjoint!.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    size_out(p)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Size of the output array for an nfft! operation. The returned tuple has R entries.  Note that this will be the input array for nfft_adjoint!.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    nfft!(p, f, fHat) -> fHat","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Inplace NFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    nfft_adjoint!(p, fHat, f) -> f","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Inplace adjoint NFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    nodes!(p, x)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Change nodes x in the plan p operation and return the plan. The implementation of this function is optional.","category":"page"},{"location":"abstract/#Plan-Interface","page":"AbstractNFFTs","title":"Plan Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The constructor for an plan also has a defined interface. It should be implemented in this way:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"function MyNFFTPlan(x::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {T,D}\n  ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"All parameters are put into keyword arguments that have to match as well. We describe the keyword arguments in more detail in the overview page.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Additionally, to the constructor an AbstractNFFTPlan implementation can provide the factory","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"plan_nfft(Q::Type, x::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {D}","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"where Q is the Array type, e.g. Array. The reason to require the array type is, that this allows for GPU implementations, which would use for instance CuArray here.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The package AbstractNFFTs provides a convenient constructor","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"plan_nfft(x::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {D}","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"defaulting to the Array type.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"note: Note\nDifferent packages implementing plan_nfft will conflict if the same Q is implemented. In case of NFFT.jl and CuNFFT.jl there is no conflict since the array type is different.","category":"page"},{"location":"abstract/#Derived-Interface","page":"AbstractNFFTs","title":"Derived Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The following derived functions are provided for all plans that inherit from AbstractNFFTPlan:","category":"page"},{"location":"abstract/#Non-preallocated-NFFT","page":"AbstractNFFTs","title":"Non-preallocated NFFT","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The following two functions allocate a fresh output vector an operate out of place","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"nfft!(p, f) -> fHat\nnfft_adjoint!(p, fHat) -> f","category":"page"},{"location":"abstract/#Non-preallocated-Plan","page":"AbstractNFFTs","title":"Non-preallocated Plan","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The following two functions perform an NFFT without a preallocated plan:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"nfft!(x, f) -> fHat\nnfft_adjoint!(x, N, fHat) -> f","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Note that N needs only be specified for the adjoint. The direct NFFT can derive it from f.","category":"page"},{"location":"abstract/#Linear-Algebra-Notation","page":"AbstractNFFTs","title":"Linear Algebra Notation","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The NFFT can also be considered as a matrix vector multiplication. Julia provides the interface","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"  *(A, x) -> b\n  mul!(b, A, x) -> b","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"for this. Both operations are implemented for any AbstractNFFTPlan. To obtain the adjoint on needs to apply adjoint(p) to the plan p before multiplication.","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Getting-Started","page":"Overview","title":"Getting Started","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Basic usage of NFFT.jl is shown in the following example for 1D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using NFFT\n\nM, N = 8, 16\nx = range(-0.4, stop=0.4, length=M)  # nodes at which the NFFT is evaluated\nfHat = randn(ComplexF64,M)           # data to be transformed\np = plan_nfft(x, N)                  # create plan. m and σ are optional parameters\nf = nfft_adjoint(p, fHat)            # calculate adjoint NFFT\ng = nfft(p, f)                       # calculate forward NFFT","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In 2D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M, N = 16, 32\nx = rand(2, M) .- 0.5\nfHat = randn(ComplexF64,M)\np = plan_nfft(x, (N,N))\nf = nfft_adjoint(p, fHat)\ng = nfft(p, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the eltype of the arguments f and fHat must be compatible that of the variable x used in the plan_nfft call. For example, if one wants to use Float32 types to save memory, then one can make the plan using something like this:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x = Float32.(LinRange(-0.5,0.5,64))\np = plan_nfft(x, N)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The plan will then internally use Float32 types. Then the arguments f and fHat above should have eltype Complex{Float32} or equivalently ComplexF32, otherwise there will be error messages.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"One can also perform NFFT computations directly without first creating a plan:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"g = nfft(x, f)\nf = nfft_adjoint(x, N, fHat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"These forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same x","category":"page"},{"location":"overview/#Parameters","page":"Overview","title":"Parameters","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The NFFT has the following parameters that can be passed as a keyword argument to the constructor ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Parameter Description Example Values\nm Kernel size. The convolution matrix has 2m+1 non-zero entries around each sampling node in each dimension. m in 2dots8\nσ Oversampling factor. The inner FFT is of size σN σ in 125 20\nwindow Convolution window: Available are :gauss,  :spline, :kaiser_bessel_rev, :kaiser_bessel. :kaiser_bessel\nprecompute Flag indicating the precomputation strategy for the convolution matrix LUT\nsortNodes Flag if the nodes should be sorted in a lexicographic way false\nstoreApodizationIdx Flag if the apodization indices should be stored. Currently this option is necessary on the GPU false\nLUTSize Size of the look up table when using precompute == NFFT.LUT 20000\nfftflags flags passed to the inner AbstractFFT as flags. This can for instance be FFTW.MEASURE in order to optimize the inner FFT FFTW.ESTIMATE","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In practice you can use for most of the values the default values. If you want to maximize speed you can set σ=1.25, m=3. If you need machine precision accuracy use  σ=2.0, m=8. ","category":"page"},{"location":"overview/#Precomputation","page":"Overview","title":"Precomputation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are different pre-computation strategies available. Again you don't need to change this if you satisfied with the default speed. The reason to have some sort of precomputation is that the NFFT is much slower if the window function is evaluated on demand.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Value Description\nNFFT.LUT This option uses a look-up table to first sample the window function and later use linear interpolation during the actual convolution. LUTSize controls the size of the look-up table. We don't have error estimates but a value of 20,000 is in practice large enough.\nNFFT.FULL This option precomputes the entire convolution matrix and stores it as a SparseMatrixCSC. This option requires more memory an requires the most precomputation time. However, the transformation itself has maximum performance. In addition it is easy to perform the NFFT on the GPU with this option, see CuNFFT.\nNFFT.TENSOR This option calculates the window on demand but exploits the tensor structure for multi-dimensional plans. Hence, this option makes no approximation but reaches a similar performance as NFFT.LUT. This option is right now only available in the NFFT3 backend.","category":"page"},{"location":"overview/#Multi-Threading","page":"Overview","title":"Multi-Threading","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Most parts of NFFT are multi-threaded when running on the CPU. To this end, start Julia with the option","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia -t T","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where T it the number of desired threads. NFFT.jl will use all threads that are specified. You can dynamically switch off multi-threading by calling the internal function","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"  NFFT._use_threads[] = false","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the number of threads used for the FFTW is not changed, i.e. you likely want to set","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"  FFTW.set_num_threads(Threads.nthreads())","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The following operations are currently multi-threaded:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"precomputation\napodization and its adjoint\nFFT (using FFTW)\nconvolution","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"What is currently missing is a multi-threaded version of the adjoint convolution, which is challenging to implement efficiently (needs blocking techniques). When using the precompute = FULL operation one could potentially exploit a sparse matrix library that supports blocking.","category":"page"},{"location":"overview/#Directional","page":"Overview","title":"Directional","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are special methods for computing 1D NFFT's for each 1D slice along a particular dimension of a higher dimensional array.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"M = 11\n\ny = rand(M) .- 0.5\nN = (16,20)\nP1 = plan_nfft(y, N, dims=1)\nf = randn(ComplexF64,N)\nfHat = nfft(P1, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here size(f) = (16,20) and size(fHat) = (11,20) since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"P2 = plan_nfft(y, N, dims=2)\nfHat = nfft(P2, f)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now size(fHat) = (16,11).","category":"page"},{"location":"background/#Mathematical-Background","page":"Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/#NDFT","page":"Background","title":"NDFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"We next define the non-equidistant discrete Fourier transform (NDFT) that corresponds to the ordinary DFT. Let bmN in (2mathbbN)^d with d in mathbbN be the dimension of the d-dimensional Fourier coefficients hatf_bmk k in I_bmN. It is defined on the index set","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"I_bmN = leftlbrace pmbk in mathbbZ^d -fracN_i2 leq bmk_i leq fracN_i2-1 i=12ldotsd rightrbrace","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"and thus represents the same data the would be considered for an ordinary DFT. The NDFT is now defined as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  \tf(bmx_j) = sum_ bmk in I_bmN hatf_bmk  mathrme^-2pimathrmibmkcdotbmx","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where bmx_j in mathbbT^d j=1dots M with M in mathbbN are the nonequidistant sampling nodes and mathbbT = 1212) is the torus and f is the d-dimensional trigonometric polynomial associated with the Fourier coefficients hatf_bmk.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The direct NDFT operator has an associated adjoint that can be formulated as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"\thatg_bmk = sum_j = 1^M f(bmx_j)  mathrme^2 pi mathrmi  bmk cdot bmx_j bmk in I_bmN","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"We note that in general the adjoint NDFT is not the inverse.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nThe indices in the index set I_bmN are centered around zero, which is the usual definition of the NFFT. In contrast the indices for the DFT usually run from 1dotsN_d. This means an fftshift needs to be applied to change from one representation to the other.","category":"page"},{"location":"background/#Matrix-Vector-Notation","page":"Background","title":"Matrix-Vector Notation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NDFT can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" bmf = bmA hatbmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"beginaligned\n bmf = left( f(bmx_j) right)_j=1^M in mathbbC^mathbfN \n hatbmf = left( hatf_bmk right)_bmk in I_mathbfN in mathbbC^M\n  bmA =  left( mathrme^2 pi mathrmi  bmk cdot bmx_j right)_j=1dotsM bmk in I_mathbfN in mathbbC^M times mathbfN\nendaligned","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The adjoint can than be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hatbmg = bmA^mathsfH  bmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where hatbmg in mathbbC^mathbfN.","category":"page"},{"location":"background/#NFFT","page":"Background","title":"NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is an approximative algorithm that realizes the NDFT in just cal O(N log N + M) steps where N = textprod(bmN). This is at the same level as the ordinary FFT with the exception that of the additional linear dependence on M which is unavoidable since all nodes need to be touched as least once.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT has two important parameters that influence its accuracy:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"the window width m in mathbbN\nthe oversampling factor sigma in mathbbR with sigma  1","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"From the later we can derive bmn = sigma bmN in (2mathbbN)^d. As the definition indicates, the oversampling factor sigma is usually adjusted such that bmn consists of even integers.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT now approximates bmAby the product of three matrices","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA approx bmB bmF bmD","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmF in mathbbC^mathbfntimes mathbfn is the regular DFT matrix.\nbmD in mathbbC^mathbfntimes mathbfN is a diagonal matrix that additionally includes zero filling and the fftshift. We call this the apodization matrix.\nbmB in mathbbC^M times mathbfn is a sparse matrix implementing the discrete convolution with a window function varphi. We call this the convolution matrix.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is based on the convolution theorem. It applies a convolution in the time/space domain, which is evaluated at equidistant sampling nodes. This convolution is then corrected in the Fourier space by division with the Fourier transform psi of varphi. The adjoint NFFT matrix approximates bmA^mathsfH by","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA^mathsfH approx bmD^mathsfH bmF^mathsfH  bmB^mathsfH ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Implementation-wise, the matrix-vector notation illustrates that the NFFT consists of three independent steps that are performed successively. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The multiplication with bmD is a scalar multiplication with the input-vector plus the shifting of data, which can be done inplace.\nThe FFT is done with a high-performance FFT library such as the FFTW.\nThe multiplication with bmB needs to run only over a subset of the indices and is the most challenging step.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Since in practice the multiplication with bmB is also the most expansive step, an NFFT library needs to pay special attention to optimizing it appropriately.","category":"page"},{"location":"background/#Directional-NFFT","page":"Background","title":"Directional NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"In many cases one not just needs to apply a single NFFT but needs to apply many on different data. This leads us to the directional NFFT. The directional NFFT is defined as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  \tf_bmljbmr = sum_ bmk in I_bmN_textsub hatf_bmlbmkbmr  mathrme^-2pimathrmibmkcdotbmx","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where now (bml bmk bmr) in I_mathbfN and bmN_textsub is a subset of bmN. The transform thus maps a D-dimensional tensor hatf_bmlbmkbmr to an R-dimensional tensor f_bmljbmr. bmN_textsub is thus a vector of length D-R+1 The indices bml and bmr can also have length zero. Thus, for R=1, the conventional NFFT arises as a special case of the directional.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nThe directional NFFT can also be considered to be a slicing of a tensor with subsequent application of a regular NFFT. But the aforementioned formulation can be used to implement a much more efficient algorithm than can be achieved with slicing.","category":"page"},{"location":"#NFFT.jl","page":"Home","title":"NFFT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the Non-equidistant Fast Fourier Transform","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the Non-equidistant Fast Fourier Transform (NFFT). For a detailed introduction into the NFFT and its application please have a look at www.nfft.org.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT is a fast implementation of the Non-equidistant Discrete Fourier Transform (NDFT) that is basically a DFT with non-equidistant sampling nodes in either Fourier or time/space domain. In contrast to the FFT, the NFFT is an approximative algorithm whereas the accuracy can be controlled by two parameters: the window width m and the oversampling factor σ.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add NFFT","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the packages NFFT.jl and all its dependencies.  If you need support for CUDA you also need to install the package CuNFFT.jl","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation starts with the Mathematical Background that properly defines the NDFT, the NFFT and its directional variants. You might want to skip this part if you are familiar with the notation and concepts of the NFFT. \nThen, an Overview about the usage of the NFFT functions is given in a tutorial style manner.  \nIn the section about the Abstract Interface for NFFTs we outline how the package is divided into an interface package and two implementation packages. This part is useful if you plan to use different NFFT implementations, e.g. one for the CPU and another for the GPU and would like to switch.\nThe section about Tools introduced some high-level functions that build upon the NFFT. For instance NFFT inversion is discussed in that section.\nThen an overview about Accuracy and Performance is given.\nImplementation outlines some implementation details.\nFinally, the documentation contains an API index.","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find bugs or have ideas for improvements please use the issue tracker. For general questions please use the discussions section on Github.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tobias Knopp\nRobert Dahl Jacobsen\nMirco Grosser\nJakob Assländer\nMosè Giordano","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete list of contributors can be found on the Github page.","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"We next indicate some implementation details and design choices being made during  the developments of NFFT.jl","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The split into ... ","category":"page"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/#Sampling-Density","page":"Tools","title":"Sampling Density","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"TODO","category":"page"},{"location":"tools/#Toeplitz-Kernel","page":"Tools","title":"Toeplitz Kernel","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"TODO","category":"page"}]
}
